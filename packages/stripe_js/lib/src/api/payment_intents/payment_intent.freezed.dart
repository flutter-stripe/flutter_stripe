// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'payment_intent.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PaymentIntent {

/// Unique identifier for the object.
 String get id;/// String representing the object’s type.
/// Objects of the same type share the same value.
/// Value is "payment_intent".
 String get object;/// Amount intended to be collected by this PaymentIntent.
/// A positive integer representing how much to charge in the
/// smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to
/// charge ¥100, a zero-decimal currency).
/// The minimum amount is $0.50 US or equivalent in charge currency.
/// The amount value supports up to eight digits
/// (e.g., a value of 99999999 for a USD charge of $999,999.99).
 int get amount;/// The amount that can be captured with from this PaymentIntent (in cents).
@JsonKey(name: "amount_capturable") int? get amountCapturable;/// Details about items included in the amount
@JsonKey(name: "amount_details") PaymentIntentAmountDetails? get amountDetails;/// The amount that was collected from this PaymentIntent (in cents).
@JsonKey(name: "amount_received") int? get amountReceived;/// CONNECT ONLY
/// ID of the Connect application that created the PaymentIntent.
 String? get application;/// CONNECT ONLY
/// The amount of the application fee (if any) that will be requested to
/// be applied to the payment and transferred to the application owner’s
/// Stripe account. The amount of the application fee collected will be
/// capped at the total payment amount.
/// For more information, see the PaymentIntents use
/// case for connected accounts..
@JsonKey(name: "application_fee_amount") int? get applicationFeeAmount;/// Settings to configure compatible payment methods from the
/// Stripe Dashboard
@JsonKey(name: "automatic_payment_methods") PaymentIntentAutomaticPaymentMethods? get automaticPaymentMethods;/// Populated when status is canceled, this is the time at which the
/// PaymentIntent was canceled. Measured in seconds since the Unix epoch.
@JsonKey(name: "canceled_at") int? get canceledAt;/// Reason for cancellation of this PaymentIntent,
/// either user-provided
/// (duplicate, fraudulent, requested_by_customer, or abandoned) or
/// generated by Stripe internally
/// (failed_invoice, void_invoice, or automatic).
@JsonKey(name: "cancellation_reason") PaymentIntentCancellationReason? get cancellationReason;/// The client secret of this PaymentIntent. Used for client-side retrieval
/// using a publishable key.
/// The client secret can be used to complete a payment from your frontend.
/// It should not be stored, logged, or exposed to anyone other than the
/// customer. Make sure that you have TLS enabled on any page that includes
/// the client secret.
///
/// Refer to our docs to accept a payment and learn about how `client_secret`
/// should be handled.
@JsonKey(name: "client_secret") String get clientSecret;/// Controls when the funds will be captured from the customer’s account.
@JsonKey(name: "capture_method") PaymentIntentCaptureMethod get captureMethod;@JsonKey(name: "confirmation_method") PaymentIntentConfirmationMethod get confirmationMethod;/// Time at which the object was created. Measured in seconds since the
/// Unix epoch.
 int? get created;/// Three-letter ISO currency code, in lowercase. Must be a supported
/// currency.
 String get currency;/// ID of the Customer this PaymentIntent belongs to, if one exists.
/// Payment methods attached to other Customers cannot be used with this
/// PaymentIntent.
///
/// If present in combination with setup_future_usage,
/// this PaymentIntent’s payment method will be attached to the
/// Customer after the PaymentIntent has been confirmed and any
/// required actions from the user are complete.
 String? get customer;/// An arbitrary string attached to the object.
/// Often useful for displaying to users.
 String? get description;/// ID of the invoice that created this PaymentIntent, if it exists.
 String? get invoice;/// The payment error encountered in the previous PaymentIntent confirmation.
/// It will be cleared if the PaymentIntent is later updated for any reason.
@JsonKey(name: "last_payment_error") StripeError? get lastPaymentError;/// The latest charge created by this payment intent.
@JsonKey(name: "latest_charge") String? get latestCharge;/// Has the value true if the object exists in live mode or the
/// value false if the object exists in test mode.
 bool get livemode;/// Set of key-value pairs that you can attach to an object.
/// This can be useful for storing additional information about the
/// object in a structured format.
 Map<String, dynamic> get metadata;/// If present, this property tells you what actions you need to
/// take in order for your customer to fulfill a payment using the
/// provided source.
@JsonKey(name: "next_action") dynamic get nextAction;/// CONNECT ONLY
/// The account (if any) for which the funds of the PaymentIntent are
/// intended. See the PaymentIntents use case for connected accounts
/// for details.
@JsonKey(name: "on_behalf_of") String? get onBehalfOf;/// ID of the payment method used in this PaymentIntent.
@JsonKey(name: "payment_method") String? get paymentMethod;/// Payment-method-specific configuration for this PaymentIntent.
@JsonKey(name: "payment_method_options") Map<dynamic, dynamic> get paymentMethodOptions;/// The list of payment method types (e.g. card) that this PaymentIntent
/// is allowed to use.
@JsonKey(name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown) List<PaymentMethodType> get paymentMethodTypes;/// If present, this property tells you about the processing state of the payment.
 dynamic get processing;/// Email address that the receipt for the resulting payment will be sent to.
/// If receipt_email is specified for a payment in live mode, a receipt
/// will be sent regardless of your email settings.
@JsonKey(name: "receipt_email") String? get receiptEmail;// ID of the review associated with this PaymentIntent, if any.
 String? get review;/// Indicates that you intend to make future payments with this
/// PaymentIntent’s payment method.
/// Providing this parameter will attach the payment method to the
/// PaymentIntent’s Customer, if present, after the PaymentIntent is
/// confirmed and any required actions from the user are complete. I
/// If no Customer was provided, the payment method can still be attached to
/// a Customer after the transaction completes.
/// When processing card payments, Stripe also uses setup_future_usage
/// to dynamically optimize your payment flow and comply with regional
/// legislation and network rules, such as SCA.
@JsonKey(name: "setup_future_usage") PaymentIntentSetupFutureUsage? get setupFutureUsage;/// Shipping information for this PaymentIntent.
 ShippingDetails? get shipping;/// For non-card charges, you can use this value as the complete
/// description that appears on your customers’ statements.
/// Must contain at least one letter, maximum 22 characters.
@JsonKey(name: "statement_descriptor") String? get statementDescriptor;/// Provides information about a card payment that customers see on
/// their statements.
/// Concatenated with the prefix (shortened descriptor) or statement
/// descriptor that’s set on the account to form the complete statement
/// descriptor. Maximum 22 characters for the concatenated descriptor.
@JsonKey(name: "statement_descriptor_suffix") String? get statementDescriptorSuffix;/// Status of this PaymentIntent, one of requires_payment_method,
/// requires_confirmation, requires_action, processing, requires_capture,
/// canceled, or succeeded.
 PaymentIntentsStatus get status;/// CONNECT ONLY
/// The data with which to automatically create a Transfer when the payment
/// is finalized. See the PaymentIntents use case for connected
/// accounts for details.
@JsonKey(name: "transfer_data") dynamic get transferData;/// CONNECT ONLY
/// A string that identifies the resulting payment as part of a group.
/// See the PaymentIntents use case for connected accounts for details.
@JsonKey(name: "transfer_group") dynamic get transferGroup;
/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PaymentIntentCopyWith<PaymentIntent> get copyWith => _$PaymentIntentCopyWithImpl<PaymentIntent>(this as PaymentIntent, _$identity);

  /// Serializes this PaymentIntent to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PaymentIntent&&(identical(other.id, id) || other.id == id)&&(identical(other.object, object) || other.object == object)&&(identical(other.amount, amount) || other.amount == amount)&&(identical(other.amountCapturable, amountCapturable) || other.amountCapturable == amountCapturable)&&(identical(other.amountDetails, amountDetails) || other.amountDetails == amountDetails)&&(identical(other.amountReceived, amountReceived) || other.amountReceived == amountReceived)&&(identical(other.application, application) || other.application == application)&&(identical(other.applicationFeeAmount, applicationFeeAmount) || other.applicationFeeAmount == applicationFeeAmount)&&(identical(other.automaticPaymentMethods, automaticPaymentMethods) || other.automaticPaymentMethods == automaticPaymentMethods)&&(identical(other.canceledAt, canceledAt) || other.canceledAt == canceledAt)&&(identical(other.cancellationReason, cancellationReason) || other.cancellationReason == cancellationReason)&&(identical(other.clientSecret, clientSecret) || other.clientSecret == clientSecret)&&(identical(other.captureMethod, captureMethod) || other.captureMethod == captureMethod)&&(identical(other.confirmationMethod, confirmationMethod) || other.confirmationMethod == confirmationMethod)&&(identical(other.created, created) || other.created == created)&&(identical(other.currency, currency) || other.currency == currency)&&(identical(other.customer, customer) || other.customer == customer)&&(identical(other.description, description) || other.description == description)&&(identical(other.invoice, invoice) || other.invoice == invoice)&&(identical(other.lastPaymentError, lastPaymentError) || other.lastPaymentError == lastPaymentError)&&(identical(other.latestCharge, latestCharge) || other.latestCharge == latestCharge)&&(identical(other.livemode, livemode) || other.livemode == livemode)&&const DeepCollectionEquality().equals(other.metadata, metadata)&&const DeepCollectionEquality().equals(other.nextAction, nextAction)&&(identical(other.onBehalfOf, onBehalfOf) || other.onBehalfOf == onBehalfOf)&&(identical(other.paymentMethod, paymentMethod) || other.paymentMethod == paymentMethod)&&const DeepCollectionEquality().equals(other.paymentMethodOptions, paymentMethodOptions)&&const DeepCollectionEquality().equals(other.paymentMethodTypes, paymentMethodTypes)&&const DeepCollectionEquality().equals(other.processing, processing)&&(identical(other.receiptEmail, receiptEmail) || other.receiptEmail == receiptEmail)&&(identical(other.review, review) || other.review == review)&&(identical(other.setupFutureUsage, setupFutureUsage) || other.setupFutureUsage == setupFutureUsage)&&(identical(other.shipping, shipping) || other.shipping == shipping)&&(identical(other.statementDescriptor, statementDescriptor) || other.statementDescriptor == statementDescriptor)&&(identical(other.statementDescriptorSuffix, statementDescriptorSuffix) || other.statementDescriptorSuffix == statementDescriptorSuffix)&&(identical(other.status, status) || other.status == status)&&const DeepCollectionEquality().equals(other.transferData, transferData)&&const DeepCollectionEquality().equals(other.transferGroup, transferGroup));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,id,object,amount,amountCapturable,amountDetails,amountReceived,application,applicationFeeAmount,automaticPaymentMethods,canceledAt,cancellationReason,clientSecret,captureMethod,confirmationMethod,created,currency,customer,description,invoice,lastPaymentError,latestCharge,livemode,const DeepCollectionEquality().hash(metadata),const DeepCollectionEquality().hash(nextAction),onBehalfOf,paymentMethod,const DeepCollectionEquality().hash(paymentMethodOptions),const DeepCollectionEquality().hash(paymentMethodTypes),const DeepCollectionEquality().hash(processing),receiptEmail,review,setupFutureUsage,shipping,statementDescriptor,statementDescriptorSuffix,status,const DeepCollectionEquality().hash(transferData),const DeepCollectionEquality().hash(transferGroup)]);

@override
String toString() {
  return 'PaymentIntent(id: $id, object: $object, amount: $amount, amountCapturable: $amountCapturable, amountDetails: $amountDetails, amountReceived: $amountReceived, application: $application, applicationFeeAmount: $applicationFeeAmount, automaticPaymentMethods: $automaticPaymentMethods, canceledAt: $canceledAt, cancellationReason: $cancellationReason, clientSecret: $clientSecret, captureMethod: $captureMethod, confirmationMethod: $confirmationMethod, created: $created, currency: $currency, customer: $customer, description: $description, invoice: $invoice, lastPaymentError: $lastPaymentError, latestCharge: $latestCharge, livemode: $livemode, metadata: $metadata, nextAction: $nextAction, onBehalfOf: $onBehalfOf, paymentMethod: $paymentMethod, paymentMethodOptions: $paymentMethodOptions, paymentMethodTypes: $paymentMethodTypes, processing: $processing, receiptEmail: $receiptEmail, review: $review, setupFutureUsage: $setupFutureUsage, shipping: $shipping, statementDescriptor: $statementDescriptor, statementDescriptorSuffix: $statementDescriptorSuffix, status: $status, transferData: $transferData, transferGroup: $transferGroup)';
}


}

/// @nodoc
abstract mixin class $PaymentIntentCopyWith<$Res>  {
  factory $PaymentIntentCopyWith(PaymentIntent value, $Res Function(PaymentIntent) _then) = _$PaymentIntentCopyWithImpl;
@useResult
$Res call({
 String id, String object, int amount,@JsonKey(name: "amount_capturable") int? amountCapturable,@JsonKey(name: "amount_details") PaymentIntentAmountDetails? amountDetails,@JsonKey(name: "amount_received") int? amountReceived, String? application,@JsonKey(name: "application_fee_amount") int? applicationFeeAmount,@JsonKey(name: "automatic_payment_methods") PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods,@JsonKey(name: "canceled_at") int? canceledAt,@JsonKey(name: "cancellation_reason") PaymentIntentCancellationReason? cancellationReason,@JsonKey(name: "client_secret") String clientSecret,@JsonKey(name: "capture_method") PaymentIntentCaptureMethod captureMethod,@JsonKey(name: "confirmation_method") PaymentIntentConfirmationMethod confirmationMethod, int? created, String currency, String? customer, String? description, String? invoice,@JsonKey(name: "last_payment_error") StripeError? lastPaymentError,@JsonKey(name: "latest_charge") String? latestCharge, bool livemode, Map<String, dynamic> metadata,@JsonKey(name: "next_action") dynamic nextAction,@JsonKey(name: "on_behalf_of") String? onBehalfOf,@JsonKey(name: "payment_method") String? paymentMethod,@JsonKey(name: "payment_method_options") Map<dynamic, dynamic> paymentMethodOptions,@JsonKey(name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown) List<PaymentMethodType> paymentMethodTypes, dynamic processing,@JsonKey(name: "receipt_email") String? receiptEmail, String? review,@JsonKey(name: "setup_future_usage") PaymentIntentSetupFutureUsage? setupFutureUsage, ShippingDetails? shipping,@JsonKey(name: "statement_descriptor") String? statementDescriptor,@JsonKey(name: "statement_descriptor_suffix") String? statementDescriptorSuffix, PaymentIntentsStatus status,@JsonKey(name: "transfer_data") dynamic transferData,@JsonKey(name: "transfer_group") dynamic transferGroup
});


$PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails;$PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>? get automaticPaymentMethods;$StripeErrorCopyWith<$Res>? get lastPaymentError;$ShippingDetailsCopyWith<$Res>? get shipping;

}
/// @nodoc
class _$PaymentIntentCopyWithImpl<$Res>
    implements $PaymentIntentCopyWith<$Res> {
  _$PaymentIntentCopyWithImpl(this._self, this._then);

  final PaymentIntent _self;
  final $Res Function(PaymentIntent) _then;

/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? object = null,Object? amount = null,Object? amountCapturable = freezed,Object? amountDetails = freezed,Object? amountReceived = freezed,Object? application = freezed,Object? applicationFeeAmount = freezed,Object? automaticPaymentMethods = freezed,Object? canceledAt = freezed,Object? cancellationReason = freezed,Object? clientSecret = null,Object? captureMethod = null,Object? confirmationMethod = null,Object? created = freezed,Object? currency = null,Object? customer = freezed,Object? description = freezed,Object? invoice = freezed,Object? lastPaymentError = freezed,Object? latestCharge = freezed,Object? livemode = null,Object? metadata = null,Object? nextAction = freezed,Object? onBehalfOf = freezed,Object? paymentMethod = freezed,Object? paymentMethodOptions = null,Object? paymentMethodTypes = null,Object? processing = freezed,Object? receiptEmail = freezed,Object? review = freezed,Object? setupFutureUsage = freezed,Object? shipping = freezed,Object? statementDescriptor = freezed,Object? statementDescriptorSuffix = freezed,Object? status = null,Object? transferData = freezed,Object? transferGroup = freezed,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,object: null == object ? _self.object : object // ignore: cast_nullable_to_non_nullable
as String,amount: null == amount ? _self.amount : amount // ignore: cast_nullable_to_non_nullable
as int,amountCapturable: freezed == amountCapturable ? _self.amountCapturable : amountCapturable // ignore: cast_nullable_to_non_nullable
as int?,amountDetails: freezed == amountDetails ? _self.amountDetails : amountDetails // ignore: cast_nullable_to_non_nullable
as PaymentIntentAmountDetails?,amountReceived: freezed == amountReceived ? _self.amountReceived : amountReceived // ignore: cast_nullable_to_non_nullable
as int?,application: freezed == application ? _self.application : application // ignore: cast_nullable_to_non_nullable
as String?,applicationFeeAmount: freezed == applicationFeeAmount ? _self.applicationFeeAmount : applicationFeeAmount // ignore: cast_nullable_to_non_nullable
as int?,automaticPaymentMethods: freezed == automaticPaymentMethods ? _self.automaticPaymentMethods : automaticPaymentMethods // ignore: cast_nullable_to_non_nullable
as PaymentIntentAutomaticPaymentMethods?,canceledAt: freezed == canceledAt ? _self.canceledAt : canceledAt // ignore: cast_nullable_to_non_nullable
as int?,cancellationReason: freezed == cancellationReason ? _self.cancellationReason : cancellationReason // ignore: cast_nullable_to_non_nullable
as PaymentIntentCancellationReason?,clientSecret: null == clientSecret ? _self.clientSecret : clientSecret // ignore: cast_nullable_to_non_nullable
as String,captureMethod: null == captureMethod ? _self.captureMethod : captureMethod // ignore: cast_nullable_to_non_nullable
as PaymentIntentCaptureMethod,confirmationMethod: null == confirmationMethod ? _self.confirmationMethod : confirmationMethod // ignore: cast_nullable_to_non_nullable
as PaymentIntentConfirmationMethod,created: freezed == created ? _self.created : created // ignore: cast_nullable_to_non_nullable
as int?,currency: null == currency ? _self.currency : currency // ignore: cast_nullable_to_non_nullable
as String,customer: freezed == customer ? _self.customer : customer // ignore: cast_nullable_to_non_nullable
as String?,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,invoice: freezed == invoice ? _self.invoice : invoice // ignore: cast_nullable_to_non_nullable
as String?,lastPaymentError: freezed == lastPaymentError ? _self.lastPaymentError : lastPaymentError // ignore: cast_nullable_to_non_nullable
as StripeError?,latestCharge: freezed == latestCharge ? _self.latestCharge : latestCharge // ignore: cast_nullable_to_non_nullable
as String?,livemode: null == livemode ? _self.livemode : livemode // ignore: cast_nullable_to_non_nullable
as bool,metadata: null == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>,nextAction: freezed == nextAction ? _self.nextAction : nextAction // ignore: cast_nullable_to_non_nullable
as dynamic,onBehalfOf: freezed == onBehalfOf ? _self.onBehalfOf : onBehalfOf // ignore: cast_nullable_to_non_nullable
as String?,paymentMethod: freezed == paymentMethod ? _self.paymentMethod : paymentMethod // ignore: cast_nullable_to_non_nullable
as String?,paymentMethodOptions: null == paymentMethodOptions ? _self.paymentMethodOptions : paymentMethodOptions // ignore: cast_nullable_to_non_nullable
as Map<dynamic, dynamic>,paymentMethodTypes: null == paymentMethodTypes ? _self.paymentMethodTypes : paymentMethodTypes // ignore: cast_nullable_to_non_nullable
as List<PaymentMethodType>,processing: freezed == processing ? _self.processing : processing // ignore: cast_nullable_to_non_nullable
as dynamic,receiptEmail: freezed == receiptEmail ? _self.receiptEmail : receiptEmail // ignore: cast_nullable_to_non_nullable
as String?,review: freezed == review ? _self.review : review // ignore: cast_nullable_to_non_nullable
as String?,setupFutureUsage: freezed == setupFutureUsage ? _self.setupFutureUsage : setupFutureUsage // ignore: cast_nullable_to_non_nullable
as PaymentIntentSetupFutureUsage?,shipping: freezed == shipping ? _self.shipping : shipping // ignore: cast_nullable_to_non_nullable
as ShippingDetails?,statementDescriptor: freezed == statementDescriptor ? _self.statementDescriptor : statementDescriptor // ignore: cast_nullable_to_non_nullable
as String?,statementDescriptorSuffix: freezed == statementDescriptorSuffix ? _self.statementDescriptorSuffix : statementDescriptorSuffix // ignore: cast_nullable_to_non_nullable
as String?,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as PaymentIntentsStatus,transferData: freezed == transferData ? _self.transferData : transferData // ignore: cast_nullable_to_non_nullable
as dynamic,transferGroup: freezed == transferGroup ? _self.transferGroup : transferGroup // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}
/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails {
    if (_self.amountDetails == null) {
    return null;
  }

  return $PaymentIntentAmountDetailsCopyWith<$Res>(_self.amountDetails!, (value) {
    return _then(_self.copyWith(amountDetails: value));
  });
}/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>? get automaticPaymentMethods {
    if (_self.automaticPaymentMethods == null) {
    return null;
  }

  return $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>(_self.automaticPaymentMethods!, (value) {
    return _then(_self.copyWith(automaticPaymentMethods: value));
  });
}/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$StripeErrorCopyWith<$Res>? get lastPaymentError {
    if (_self.lastPaymentError == null) {
    return null;
  }

  return $StripeErrorCopyWith<$Res>(_self.lastPaymentError!, (value) {
    return _then(_self.copyWith(lastPaymentError: value));
  });
}/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShippingDetailsCopyWith<$Res>? get shipping {
    if (_self.shipping == null) {
    return null;
  }

  return $ShippingDetailsCopyWith<$Res>(_self.shipping!, (value) {
    return _then(_self.copyWith(shipping: value));
  });
}
}


/// Adds pattern-matching-related methods to [PaymentIntent].
extension PaymentIntentPatterns on PaymentIntent {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _PaymentIntent value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _PaymentIntent() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _PaymentIntent value)  $default,){
final _that = this;
switch (_that) {
case _PaymentIntent():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _PaymentIntent value)?  $default,){
final _that = this;
switch (_that) {
case _PaymentIntent() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String object,  int amount, @JsonKey(name: "amount_capturable")  int? amountCapturable, @JsonKey(name: "amount_details")  PaymentIntentAmountDetails? amountDetails, @JsonKey(name: "amount_received")  int? amountReceived,  String? application, @JsonKey(name: "application_fee_amount")  int? applicationFeeAmount, @JsonKey(name: "automatic_payment_methods")  PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods, @JsonKey(name: "canceled_at")  int? canceledAt, @JsonKey(name: "cancellation_reason")  PaymentIntentCancellationReason? cancellationReason, @JsonKey(name: "client_secret")  String clientSecret, @JsonKey(name: "capture_method")  PaymentIntentCaptureMethod captureMethod, @JsonKey(name: "confirmation_method")  PaymentIntentConfirmationMethod confirmationMethod,  int? created,  String currency,  String? customer,  String? description,  String? invoice, @JsonKey(name: "last_payment_error")  StripeError? lastPaymentError, @JsonKey(name: "latest_charge")  String? latestCharge,  bool livemode,  Map<String, dynamic> metadata, @JsonKey(name: "next_action")  dynamic nextAction, @JsonKey(name: "on_behalf_of")  String? onBehalfOf, @JsonKey(name: "payment_method")  String? paymentMethod, @JsonKey(name: "payment_method_options")  Map<dynamic, dynamic> paymentMethodOptions, @JsonKey(name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown)  List<PaymentMethodType> paymentMethodTypes,  dynamic processing, @JsonKey(name: "receipt_email")  String? receiptEmail,  String? review, @JsonKey(name: "setup_future_usage")  PaymentIntentSetupFutureUsage? setupFutureUsage,  ShippingDetails? shipping, @JsonKey(name: "statement_descriptor")  String? statementDescriptor, @JsonKey(name: "statement_descriptor_suffix")  String? statementDescriptorSuffix,  PaymentIntentsStatus status, @JsonKey(name: "transfer_data")  dynamic transferData, @JsonKey(name: "transfer_group")  dynamic transferGroup)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _PaymentIntent() when $default != null:
return $default(_that.id,_that.object,_that.amount,_that.amountCapturable,_that.amountDetails,_that.amountReceived,_that.application,_that.applicationFeeAmount,_that.automaticPaymentMethods,_that.canceledAt,_that.cancellationReason,_that.clientSecret,_that.captureMethod,_that.confirmationMethod,_that.created,_that.currency,_that.customer,_that.description,_that.invoice,_that.lastPaymentError,_that.latestCharge,_that.livemode,_that.metadata,_that.nextAction,_that.onBehalfOf,_that.paymentMethod,_that.paymentMethodOptions,_that.paymentMethodTypes,_that.processing,_that.receiptEmail,_that.review,_that.setupFutureUsage,_that.shipping,_that.statementDescriptor,_that.statementDescriptorSuffix,_that.status,_that.transferData,_that.transferGroup);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String object,  int amount, @JsonKey(name: "amount_capturable")  int? amountCapturable, @JsonKey(name: "amount_details")  PaymentIntentAmountDetails? amountDetails, @JsonKey(name: "amount_received")  int? amountReceived,  String? application, @JsonKey(name: "application_fee_amount")  int? applicationFeeAmount, @JsonKey(name: "automatic_payment_methods")  PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods, @JsonKey(name: "canceled_at")  int? canceledAt, @JsonKey(name: "cancellation_reason")  PaymentIntentCancellationReason? cancellationReason, @JsonKey(name: "client_secret")  String clientSecret, @JsonKey(name: "capture_method")  PaymentIntentCaptureMethod captureMethod, @JsonKey(name: "confirmation_method")  PaymentIntentConfirmationMethod confirmationMethod,  int? created,  String currency,  String? customer,  String? description,  String? invoice, @JsonKey(name: "last_payment_error")  StripeError? lastPaymentError, @JsonKey(name: "latest_charge")  String? latestCharge,  bool livemode,  Map<String, dynamic> metadata, @JsonKey(name: "next_action")  dynamic nextAction, @JsonKey(name: "on_behalf_of")  String? onBehalfOf, @JsonKey(name: "payment_method")  String? paymentMethod, @JsonKey(name: "payment_method_options")  Map<dynamic, dynamic> paymentMethodOptions, @JsonKey(name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown)  List<PaymentMethodType> paymentMethodTypes,  dynamic processing, @JsonKey(name: "receipt_email")  String? receiptEmail,  String? review, @JsonKey(name: "setup_future_usage")  PaymentIntentSetupFutureUsage? setupFutureUsage,  ShippingDetails? shipping, @JsonKey(name: "statement_descriptor")  String? statementDescriptor, @JsonKey(name: "statement_descriptor_suffix")  String? statementDescriptorSuffix,  PaymentIntentsStatus status, @JsonKey(name: "transfer_data")  dynamic transferData, @JsonKey(name: "transfer_group")  dynamic transferGroup)  $default,) {final _that = this;
switch (_that) {
case _PaymentIntent():
return $default(_that.id,_that.object,_that.amount,_that.amountCapturable,_that.amountDetails,_that.amountReceived,_that.application,_that.applicationFeeAmount,_that.automaticPaymentMethods,_that.canceledAt,_that.cancellationReason,_that.clientSecret,_that.captureMethod,_that.confirmationMethod,_that.created,_that.currency,_that.customer,_that.description,_that.invoice,_that.lastPaymentError,_that.latestCharge,_that.livemode,_that.metadata,_that.nextAction,_that.onBehalfOf,_that.paymentMethod,_that.paymentMethodOptions,_that.paymentMethodTypes,_that.processing,_that.receiptEmail,_that.review,_that.setupFutureUsage,_that.shipping,_that.statementDescriptor,_that.statementDescriptorSuffix,_that.status,_that.transferData,_that.transferGroup);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String object,  int amount, @JsonKey(name: "amount_capturable")  int? amountCapturable, @JsonKey(name: "amount_details")  PaymentIntentAmountDetails? amountDetails, @JsonKey(name: "amount_received")  int? amountReceived,  String? application, @JsonKey(name: "application_fee_amount")  int? applicationFeeAmount, @JsonKey(name: "automatic_payment_methods")  PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods, @JsonKey(name: "canceled_at")  int? canceledAt, @JsonKey(name: "cancellation_reason")  PaymentIntentCancellationReason? cancellationReason, @JsonKey(name: "client_secret")  String clientSecret, @JsonKey(name: "capture_method")  PaymentIntentCaptureMethod captureMethod, @JsonKey(name: "confirmation_method")  PaymentIntentConfirmationMethod confirmationMethod,  int? created,  String currency,  String? customer,  String? description,  String? invoice, @JsonKey(name: "last_payment_error")  StripeError? lastPaymentError, @JsonKey(name: "latest_charge")  String? latestCharge,  bool livemode,  Map<String, dynamic> metadata, @JsonKey(name: "next_action")  dynamic nextAction, @JsonKey(name: "on_behalf_of")  String? onBehalfOf, @JsonKey(name: "payment_method")  String? paymentMethod, @JsonKey(name: "payment_method_options")  Map<dynamic, dynamic> paymentMethodOptions, @JsonKey(name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown)  List<PaymentMethodType> paymentMethodTypes,  dynamic processing, @JsonKey(name: "receipt_email")  String? receiptEmail,  String? review, @JsonKey(name: "setup_future_usage")  PaymentIntentSetupFutureUsage? setupFutureUsage,  ShippingDetails? shipping, @JsonKey(name: "statement_descriptor")  String? statementDescriptor, @JsonKey(name: "statement_descriptor_suffix")  String? statementDescriptorSuffix,  PaymentIntentsStatus status, @JsonKey(name: "transfer_data")  dynamic transferData, @JsonKey(name: "transfer_group")  dynamic transferGroup)?  $default,) {final _that = this;
switch (_that) {
case _PaymentIntent() when $default != null:
return $default(_that.id,_that.object,_that.amount,_that.amountCapturable,_that.amountDetails,_that.amountReceived,_that.application,_that.applicationFeeAmount,_that.automaticPaymentMethods,_that.canceledAt,_that.cancellationReason,_that.clientSecret,_that.captureMethod,_that.confirmationMethod,_that.created,_that.currency,_that.customer,_that.description,_that.invoice,_that.lastPaymentError,_that.latestCharge,_that.livemode,_that.metadata,_that.nextAction,_that.onBehalfOf,_that.paymentMethod,_that.paymentMethodOptions,_that.paymentMethodTypes,_that.processing,_that.receiptEmail,_that.review,_that.setupFutureUsage,_that.shipping,_that.statementDescriptor,_that.statementDescriptorSuffix,_that.status,_that.transferData,_that.transferGroup);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _PaymentIntent implements PaymentIntent {
  const _PaymentIntent({required this.id, this.object = "payment_intent", required this.amount, @JsonKey(name: "amount_capturable") this.amountCapturable, @JsonKey(name: "amount_details") this.amountDetails = const PaymentIntentAmountDetails(), @JsonKey(name: "amount_received") this.amountReceived, this.application, @JsonKey(name: "application_fee_amount") this.applicationFeeAmount, @JsonKey(name: "automatic_payment_methods") this.automaticPaymentMethods, @JsonKey(name: "canceled_at") this.canceledAt, @JsonKey(name: "cancellation_reason") this.cancellationReason, @JsonKey(name: "client_secret") required this.clientSecret, @JsonKey(name: "capture_method") this.captureMethod = PaymentIntentCaptureMethod.automatic, @JsonKey(name: "confirmation_method") this.confirmationMethod = PaymentIntentConfirmationMethod.automatic, this.created, required this.currency, this.customer, this.description, this.invoice, @JsonKey(name: "last_payment_error") this.lastPaymentError, @JsonKey(name: "latest_charge") this.latestCharge, required this.livemode, final  Map<String, dynamic> metadata = const {}, @JsonKey(name: "next_action") this.nextAction, @JsonKey(name: "on_behalf_of") this.onBehalfOf, @JsonKey(name: "payment_method") this.paymentMethod, @JsonKey(name: "payment_method_options") final  Map<dynamic, dynamic> paymentMethodOptions = const {}, @JsonKey(name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown) final  List<PaymentMethodType> paymentMethodTypes = const [], this.processing, @JsonKey(name: "receipt_email") this.receiptEmail, this.review, @JsonKey(name: "setup_future_usage") this.setupFutureUsage, this.shipping, @JsonKey(name: "statement_descriptor") this.statementDescriptor, @JsonKey(name: "statement_descriptor_suffix") this.statementDescriptorSuffix, required this.status, @JsonKey(name: "transfer_data") this.transferData, @JsonKey(name: "transfer_group") this.transferGroup}): _metadata = metadata,_paymentMethodOptions = paymentMethodOptions,_paymentMethodTypes = paymentMethodTypes;
  factory _PaymentIntent.fromJson(Map<String, dynamic> json) => _$PaymentIntentFromJson(json);

/// Unique identifier for the object.
@override final  String id;
/// String representing the object’s type.
/// Objects of the same type share the same value.
/// Value is "payment_intent".
@override@JsonKey() final  String object;
/// Amount intended to be collected by this PaymentIntent.
/// A positive integer representing how much to charge in the
/// smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to
/// charge ¥100, a zero-decimal currency).
/// The minimum amount is $0.50 US or equivalent in charge currency.
/// The amount value supports up to eight digits
/// (e.g., a value of 99999999 for a USD charge of $999,999.99).
@override final  int amount;
/// The amount that can be captured with from this PaymentIntent (in cents).
@override@JsonKey(name: "amount_capturable") final  int? amountCapturable;
/// Details about items included in the amount
@override@JsonKey(name: "amount_details") final  PaymentIntentAmountDetails? amountDetails;
/// The amount that was collected from this PaymentIntent (in cents).
@override@JsonKey(name: "amount_received") final  int? amountReceived;
/// CONNECT ONLY
/// ID of the Connect application that created the PaymentIntent.
@override final  String? application;
/// CONNECT ONLY
/// The amount of the application fee (if any) that will be requested to
/// be applied to the payment and transferred to the application owner’s
/// Stripe account. The amount of the application fee collected will be
/// capped at the total payment amount.
/// For more information, see the PaymentIntents use
/// case for connected accounts..
@override@JsonKey(name: "application_fee_amount") final  int? applicationFeeAmount;
/// Settings to configure compatible payment methods from the
/// Stripe Dashboard
@override@JsonKey(name: "automatic_payment_methods") final  PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods;
/// Populated when status is canceled, this is the time at which the
/// PaymentIntent was canceled. Measured in seconds since the Unix epoch.
@override@JsonKey(name: "canceled_at") final  int? canceledAt;
/// Reason for cancellation of this PaymentIntent,
/// either user-provided
/// (duplicate, fraudulent, requested_by_customer, or abandoned) or
/// generated by Stripe internally
/// (failed_invoice, void_invoice, or automatic).
@override@JsonKey(name: "cancellation_reason") final  PaymentIntentCancellationReason? cancellationReason;
/// The client secret of this PaymentIntent. Used for client-side retrieval
/// using a publishable key.
/// The client secret can be used to complete a payment from your frontend.
/// It should not be stored, logged, or exposed to anyone other than the
/// customer. Make sure that you have TLS enabled on any page that includes
/// the client secret.
///
/// Refer to our docs to accept a payment and learn about how `client_secret`
/// should be handled.
@override@JsonKey(name: "client_secret") final  String clientSecret;
/// Controls when the funds will be captured from the customer’s account.
@override@JsonKey(name: "capture_method") final  PaymentIntentCaptureMethod captureMethod;
@override@JsonKey(name: "confirmation_method") final  PaymentIntentConfirmationMethod confirmationMethod;
/// Time at which the object was created. Measured in seconds since the
/// Unix epoch.
@override final  int? created;
/// Three-letter ISO currency code, in lowercase. Must be a supported
/// currency.
@override final  String currency;
/// ID of the Customer this PaymentIntent belongs to, if one exists.
/// Payment methods attached to other Customers cannot be used with this
/// PaymentIntent.
///
/// If present in combination with setup_future_usage,
/// this PaymentIntent’s payment method will be attached to the
/// Customer after the PaymentIntent has been confirmed and any
/// required actions from the user are complete.
@override final  String? customer;
/// An arbitrary string attached to the object.
/// Often useful for displaying to users.
@override final  String? description;
/// ID of the invoice that created this PaymentIntent, if it exists.
@override final  String? invoice;
/// The payment error encountered in the previous PaymentIntent confirmation.
/// It will be cleared if the PaymentIntent is later updated for any reason.
@override@JsonKey(name: "last_payment_error") final  StripeError? lastPaymentError;
/// The latest charge created by this payment intent.
@override@JsonKey(name: "latest_charge") final  String? latestCharge;
/// Has the value true if the object exists in live mode or the
/// value false if the object exists in test mode.
@override final  bool livemode;
/// Set of key-value pairs that you can attach to an object.
/// This can be useful for storing additional information about the
/// object in a structured format.
 final  Map<String, dynamic> _metadata;
/// Set of key-value pairs that you can attach to an object.
/// This can be useful for storing additional information about the
/// object in a structured format.
@override@JsonKey() Map<String, dynamic> get metadata {
  if (_metadata is EqualUnmodifiableMapView) return _metadata;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_metadata);
}

/// If present, this property tells you what actions you need to
/// take in order for your customer to fulfill a payment using the
/// provided source.
@override@JsonKey(name: "next_action") final  dynamic nextAction;
/// CONNECT ONLY
/// The account (if any) for which the funds of the PaymentIntent are
/// intended. See the PaymentIntents use case for connected accounts
/// for details.
@override@JsonKey(name: "on_behalf_of") final  String? onBehalfOf;
/// ID of the payment method used in this PaymentIntent.
@override@JsonKey(name: "payment_method") final  String? paymentMethod;
/// Payment-method-specific configuration for this PaymentIntent.
 final  Map<dynamic, dynamic> _paymentMethodOptions;
/// Payment-method-specific configuration for this PaymentIntent.
@override@JsonKey(name: "payment_method_options") Map<dynamic, dynamic> get paymentMethodOptions {
  if (_paymentMethodOptions is EqualUnmodifiableMapView) return _paymentMethodOptions;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_paymentMethodOptions);
}

/// The list of payment method types (e.g. card) that this PaymentIntent
/// is allowed to use.
 final  List<PaymentMethodType> _paymentMethodTypes;
/// The list of payment method types (e.g. card) that this PaymentIntent
/// is allowed to use.
@override@JsonKey(name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown) List<PaymentMethodType> get paymentMethodTypes {
  if (_paymentMethodTypes is EqualUnmodifiableListView) return _paymentMethodTypes;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_paymentMethodTypes);
}

/// If present, this property tells you about the processing state of the payment.
@override final  dynamic processing;
/// Email address that the receipt for the resulting payment will be sent to.
/// If receipt_email is specified for a payment in live mode, a receipt
/// will be sent regardless of your email settings.
@override@JsonKey(name: "receipt_email") final  String? receiptEmail;
// ID of the review associated with this PaymentIntent, if any.
@override final  String? review;
/// Indicates that you intend to make future payments with this
/// PaymentIntent’s payment method.
/// Providing this parameter will attach the payment method to the
/// PaymentIntent’s Customer, if present, after the PaymentIntent is
/// confirmed and any required actions from the user are complete. I
/// If no Customer was provided, the payment method can still be attached to
/// a Customer after the transaction completes.
/// When processing card payments, Stripe also uses setup_future_usage
/// to dynamically optimize your payment flow and comply with regional
/// legislation and network rules, such as SCA.
@override@JsonKey(name: "setup_future_usage") final  PaymentIntentSetupFutureUsage? setupFutureUsage;
/// Shipping information for this PaymentIntent.
@override final  ShippingDetails? shipping;
/// For non-card charges, you can use this value as the complete
/// description that appears on your customers’ statements.
/// Must contain at least one letter, maximum 22 characters.
@override@JsonKey(name: "statement_descriptor") final  String? statementDescriptor;
/// Provides information about a card payment that customers see on
/// their statements.
/// Concatenated with the prefix (shortened descriptor) or statement
/// descriptor that’s set on the account to form the complete statement
/// descriptor. Maximum 22 characters for the concatenated descriptor.
@override@JsonKey(name: "statement_descriptor_suffix") final  String? statementDescriptorSuffix;
/// Status of this PaymentIntent, one of requires_payment_method,
/// requires_confirmation, requires_action, processing, requires_capture,
/// canceled, or succeeded.
@override final  PaymentIntentsStatus status;
/// CONNECT ONLY
/// The data with which to automatically create a Transfer when the payment
/// is finalized. See the PaymentIntents use case for connected
/// accounts for details.
@override@JsonKey(name: "transfer_data") final  dynamic transferData;
/// CONNECT ONLY
/// A string that identifies the resulting payment as part of a group.
/// See the PaymentIntents use case for connected accounts for details.
@override@JsonKey(name: "transfer_group") final  dynamic transferGroup;

/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PaymentIntentCopyWith<_PaymentIntent> get copyWith => __$PaymentIntentCopyWithImpl<_PaymentIntent>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PaymentIntentToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PaymentIntent&&(identical(other.id, id) || other.id == id)&&(identical(other.object, object) || other.object == object)&&(identical(other.amount, amount) || other.amount == amount)&&(identical(other.amountCapturable, amountCapturable) || other.amountCapturable == amountCapturable)&&(identical(other.amountDetails, amountDetails) || other.amountDetails == amountDetails)&&(identical(other.amountReceived, amountReceived) || other.amountReceived == amountReceived)&&(identical(other.application, application) || other.application == application)&&(identical(other.applicationFeeAmount, applicationFeeAmount) || other.applicationFeeAmount == applicationFeeAmount)&&(identical(other.automaticPaymentMethods, automaticPaymentMethods) || other.automaticPaymentMethods == automaticPaymentMethods)&&(identical(other.canceledAt, canceledAt) || other.canceledAt == canceledAt)&&(identical(other.cancellationReason, cancellationReason) || other.cancellationReason == cancellationReason)&&(identical(other.clientSecret, clientSecret) || other.clientSecret == clientSecret)&&(identical(other.captureMethod, captureMethod) || other.captureMethod == captureMethod)&&(identical(other.confirmationMethod, confirmationMethod) || other.confirmationMethod == confirmationMethod)&&(identical(other.created, created) || other.created == created)&&(identical(other.currency, currency) || other.currency == currency)&&(identical(other.customer, customer) || other.customer == customer)&&(identical(other.description, description) || other.description == description)&&(identical(other.invoice, invoice) || other.invoice == invoice)&&(identical(other.lastPaymentError, lastPaymentError) || other.lastPaymentError == lastPaymentError)&&(identical(other.latestCharge, latestCharge) || other.latestCharge == latestCharge)&&(identical(other.livemode, livemode) || other.livemode == livemode)&&const DeepCollectionEquality().equals(other._metadata, _metadata)&&const DeepCollectionEquality().equals(other.nextAction, nextAction)&&(identical(other.onBehalfOf, onBehalfOf) || other.onBehalfOf == onBehalfOf)&&(identical(other.paymentMethod, paymentMethod) || other.paymentMethod == paymentMethod)&&const DeepCollectionEquality().equals(other._paymentMethodOptions, _paymentMethodOptions)&&const DeepCollectionEquality().equals(other._paymentMethodTypes, _paymentMethodTypes)&&const DeepCollectionEquality().equals(other.processing, processing)&&(identical(other.receiptEmail, receiptEmail) || other.receiptEmail == receiptEmail)&&(identical(other.review, review) || other.review == review)&&(identical(other.setupFutureUsage, setupFutureUsage) || other.setupFutureUsage == setupFutureUsage)&&(identical(other.shipping, shipping) || other.shipping == shipping)&&(identical(other.statementDescriptor, statementDescriptor) || other.statementDescriptor == statementDescriptor)&&(identical(other.statementDescriptorSuffix, statementDescriptorSuffix) || other.statementDescriptorSuffix == statementDescriptorSuffix)&&(identical(other.status, status) || other.status == status)&&const DeepCollectionEquality().equals(other.transferData, transferData)&&const DeepCollectionEquality().equals(other.transferGroup, transferGroup));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,id,object,amount,amountCapturable,amountDetails,amountReceived,application,applicationFeeAmount,automaticPaymentMethods,canceledAt,cancellationReason,clientSecret,captureMethod,confirmationMethod,created,currency,customer,description,invoice,lastPaymentError,latestCharge,livemode,const DeepCollectionEquality().hash(_metadata),const DeepCollectionEquality().hash(nextAction),onBehalfOf,paymentMethod,const DeepCollectionEquality().hash(_paymentMethodOptions),const DeepCollectionEquality().hash(_paymentMethodTypes),const DeepCollectionEquality().hash(processing),receiptEmail,review,setupFutureUsage,shipping,statementDescriptor,statementDescriptorSuffix,status,const DeepCollectionEquality().hash(transferData),const DeepCollectionEquality().hash(transferGroup)]);

@override
String toString() {
  return 'PaymentIntent(id: $id, object: $object, amount: $amount, amountCapturable: $amountCapturable, amountDetails: $amountDetails, amountReceived: $amountReceived, application: $application, applicationFeeAmount: $applicationFeeAmount, automaticPaymentMethods: $automaticPaymentMethods, canceledAt: $canceledAt, cancellationReason: $cancellationReason, clientSecret: $clientSecret, captureMethod: $captureMethod, confirmationMethod: $confirmationMethod, created: $created, currency: $currency, customer: $customer, description: $description, invoice: $invoice, lastPaymentError: $lastPaymentError, latestCharge: $latestCharge, livemode: $livemode, metadata: $metadata, nextAction: $nextAction, onBehalfOf: $onBehalfOf, paymentMethod: $paymentMethod, paymentMethodOptions: $paymentMethodOptions, paymentMethodTypes: $paymentMethodTypes, processing: $processing, receiptEmail: $receiptEmail, review: $review, setupFutureUsage: $setupFutureUsage, shipping: $shipping, statementDescriptor: $statementDescriptor, statementDescriptorSuffix: $statementDescriptorSuffix, status: $status, transferData: $transferData, transferGroup: $transferGroup)';
}


}

/// @nodoc
abstract mixin class _$PaymentIntentCopyWith<$Res> implements $PaymentIntentCopyWith<$Res> {
  factory _$PaymentIntentCopyWith(_PaymentIntent value, $Res Function(_PaymentIntent) _then) = __$PaymentIntentCopyWithImpl;
@override @useResult
$Res call({
 String id, String object, int amount,@JsonKey(name: "amount_capturable") int? amountCapturable,@JsonKey(name: "amount_details") PaymentIntentAmountDetails? amountDetails,@JsonKey(name: "amount_received") int? amountReceived, String? application,@JsonKey(name: "application_fee_amount") int? applicationFeeAmount,@JsonKey(name: "automatic_payment_methods") PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods,@JsonKey(name: "canceled_at") int? canceledAt,@JsonKey(name: "cancellation_reason") PaymentIntentCancellationReason? cancellationReason,@JsonKey(name: "client_secret") String clientSecret,@JsonKey(name: "capture_method") PaymentIntentCaptureMethod captureMethod,@JsonKey(name: "confirmation_method") PaymentIntentConfirmationMethod confirmationMethod, int? created, String currency, String? customer, String? description, String? invoice,@JsonKey(name: "last_payment_error") StripeError? lastPaymentError,@JsonKey(name: "latest_charge") String? latestCharge, bool livemode, Map<String, dynamic> metadata,@JsonKey(name: "next_action") dynamic nextAction,@JsonKey(name: "on_behalf_of") String? onBehalfOf,@JsonKey(name: "payment_method") String? paymentMethod,@JsonKey(name: "payment_method_options") Map<dynamic, dynamic> paymentMethodOptions,@JsonKey(name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown) List<PaymentMethodType> paymentMethodTypes, dynamic processing,@JsonKey(name: "receipt_email") String? receiptEmail, String? review,@JsonKey(name: "setup_future_usage") PaymentIntentSetupFutureUsage? setupFutureUsage, ShippingDetails? shipping,@JsonKey(name: "statement_descriptor") String? statementDescriptor,@JsonKey(name: "statement_descriptor_suffix") String? statementDescriptorSuffix, PaymentIntentsStatus status,@JsonKey(name: "transfer_data") dynamic transferData,@JsonKey(name: "transfer_group") dynamic transferGroup
});


@override $PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails;@override $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>? get automaticPaymentMethods;@override $StripeErrorCopyWith<$Res>? get lastPaymentError;@override $ShippingDetailsCopyWith<$Res>? get shipping;

}
/// @nodoc
class __$PaymentIntentCopyWithImpl<$Res>
    implements _$PaymentIntentCopyWith<$Res> {
  __$PaymentIntentCopyWithImpl(this._self, this._then);

  final _PaymentIntent _self;
  final $Res Function(_PaymentIntent) _then;

/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? object = null,Object? amount = null,Object? amountCapturable = freezed,Object? amountDetails = freezed,Object? amountReceived = freezed,Object? application = freezed,Object? applicationFeeAmount = freezed,Object? automaticPaymentMethods = freezed,Object? canceledAt = freezed,Object? cancellationReason = freezed,Object? clientSecret = null,Object? captureMethod = null,Object? confirmationMethod = null,Object? created = freezed,Object? currency = null,Object? customer = freezed,Object? description = freezed,Object? invoice = freezed,Object? lastPaymentError = freezed,Object? latestCharge = freezed,Object? livemode = null,Object? metadata = null,Object? nextAction = freezed,Object? onBehalfOf = freezed,Object? paymentMethod = freezed,Object? paymentMethodOptions = null,Object? paymentMethodTypes = null,Object? processing = freezed,Object? receiptEmail = freezed,Object? review = freezed,Object? setupFutureUsage = freezed,Object? shipping = freezed,Object? statementDescriptor = freezed,Object? statementDescriptorSuffix = freezed,Object? status = null,Object? transferData = freezed,Object? transferGroup = freezed,}) {
  return _then(_PaymentIntent(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,object: null == object ? _self.object : object // ignore: cast_nullable_to_non_nullable
as String,amount: null == amount ? _self.amount : amount // ignore: cast_nullable_to_non_nullable
as int,amountCapturable: freezed == amountCapturable ? _self.amountCapturable : amountCapturable // ignore: cast_nullable_to_non_nullable
as int?,amountDetails: freezed == amountDetails ? _self.amountDetails : amountDetails // ignore: cast_nullable_to_non_nullable
as PaymentIntentAmountDetails?,amountReceived: freezed == amountReceived ? _self.amountReceived : amountReceived // ignore: cast_nullable_to_non_nullable
as int?,application: freezed == application ? _self.application : application // ignore: cast_nullable_to_non_nullable
as String?,applicationFeeAmount: freezed == applicationFeeAmount ? _self.applicationFeeAmount : applicationFeeAmount // ignore: cast_nullable_to_non_nullable
as int?,automaticPaymentMethods: freezed == automaticPaymentMethods ? _self.automaticPaymentMethods : automaticPaymentMethods // ignore: cast_nullable_to_non_nullable
as PaymentIntentAutomaticPaymentMethods?,canceledAt: freezed == canceledAt ? _self.canceledAt : canceledAt // ignore: cast_nullable_to_non_nullable
as int?,cancellationReason: freezed == cancellationReason ? _self.cancellationReason : cancellationReason // ignore: cast_nullable_to_non_nullable
as PaymentIntentCancellationReason?,clientSecret: null == clientSecret ? _self.clientSecret : clientSecret // ignore: cast_nullable_to_non_nullable
as String,captureMethod: null == captureMethod ? _self.captureMethod : captureMethod // ignore: cast_nullable_to_non_nullable
as PaymentIntentCaptureMethod,confirmationMethod: null == confirmationMethod ? _self.confirmationMethod : confirmationMethod // ignore: cast_nullable_to_non_nullable
as PaymentIntentConfirmationMethod,created: freezed == created ? _self.created : created // ignore: cast_nullable_to_non_nullable
as int?,currency: null == currency ? _self.currency : currency // ignore: cast_nullable_to_non_nullable
as String,customer: freezed == customer ? _self.customer : customer // ignore: cast_nullable_to_non_nullable
as String?,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,invoice: freezed == invoice ? _self.invoice : invoice // ignore: cast_nullable_to_non_nullable
as String?,lastPaymentError: freezed == lastPaymentError ? _self.lastPaymentError : lastPaymentError // ignore: cast_nullable_to_non_nullable
as StripeError?,latestCharge: freezed == latestCharge ? _self.latestCharge : latestCharge // ignore: cast_nullable_to_non_nullable
as String?,livemode: null == livemode ? _self.livemode : livemode // ignore: cast_nullable_to_non_nullable
as bool,metadata: null == metadata ? _self._metadata : metadata // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>,nextAction: freezed == nextAction ? _self.nextAction : nextAction // ignore: cast_nullable_to_non_nullable
as dynamic,onBehalfOf: freezed == onBehalfOf ? _self.onBehalfOf : onBehalfOf // ignore: cast_nullable_to_non_nullable
as String?,paymentMethod: freezed == paymentMethod ? _self.paymentMethod : paymentMethod // ignore: cast_nullable_to_non_nullable
as String?,paymentMethodOptions: null == paymentMethodOptions ? _self._paymentMethodOptions : paymentMethodOptions // ignore: cast_nullable_to_non_nullable
as Map<dynamic, dynamic>,paymentMethodTypes: null == paymentMethodTypes ? _self._paymentMethodTypes : paymentMethodTypes // ignore: cast_nullable_to_non_nullable
as List<PaymentMethodType>,processing: freezed == processing ? _self.processing : processing // ignore: cast_nullable_to_non_nullable
as dynamic,receiptEmail: freezed == receiptEmail ? _self.receiptEmail : receiptEmail // ignore: cast_nullable_to_non_nullable
as String?,review: freezed == review ? _self.review : review // ignore: cast_nullable_to_non_nullable
as String?,setupFutureUsage: freezed == setupFutureUsage ? _self.setupFutureUsage : setupFutureUsage // ignore: cast_nullable_to_non_nullable
as PaymentIntentSetupFutureUsage?,shipping: freezed == shipping ? _self.shipping : shipping // ignore: cast_nullable_to_non_nullable
as ShippingDetails?,statementDescriptor: freezed == statementDescriptor ? _self.statementDescriptor : statementDescriptor // ignore: cast_nullable_to_non_nullable
as String?,statementDescriptorSuffix: freezed == statementDescriptorSuffix ? _self.statementDescriptorSuffix : statementDescriptorSuffix // ignore: cast_nullable_to_non_nullable
as String?,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as PaymentIntentsStatus,transferData: freezed == transferData ? _self.transferData : transferData // ignore: cast_nullable_to_non_nullable
as dynamic,transferGroup: freezed == transferGroup ? _self.transferGroup : transferGroup // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}

/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails {
    if (_self.amountDetails == null) {
    return null;
  }

  return $PaymentIntentAmountDetailsCopyWith<$Res>(_self.amountDetails!, (value) {
    return _then(_self.copyWith(amountDetails: value));
  });
}/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>? get automaticPaymentMethods {
    if (_self.automaticPaymentMethods == null) {
    return null;
  }

  return $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>(_self.automaticPaymentMethods!, (value) {
    return _then(_self.copyWith(automaticPaymentMethods: value));
  });
}/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$StripeErrorCopyWith<$Res>? get lastPaymentError {
    if (_self.lastPaymentError == null) {
    return null;
  }

  return $StripeErrorCopyWith<$Res>(_self.lastPaymentError!, (value) {
    return _then(_self.copyWith(lastPaymentError: value));
  });
}/// Create a copy of PaymentIntent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShippingDetailsCopyWith<$Res>? get shipping {
    if (_self.shipping == null) {
    return null;
  }

  return $ShippingDetailsCopyWith<$Res>(_self.shipping!, (value) {
    return _then(_self.copyWith(shipping: value));
  });
}
}


/// @nodoc
mixin _$PaymentIntentAmountDetails {

/// Details about items included in the amount
 PaymentIntentTip? get tip;
/// Create a copy of PaymentIntentAmountDetails
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PaymentIntentAmountDetailsCopyWith<PaymentIntentAmountDetails> get copyWith => _$PaymentIntentAmountDetailsCopyWithImpl<PaymentIntentAmountDetails>(this as PaymentIntentAmountDetails, _$identity);

  /// Serializes this PaymentIntentAmountDetails to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PaymentIntentAmountDetails&&(identical(other.tip, tip) || other.tip == tip));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tip);

@override
String toString() {
  return 'PaymentIntentAmountDetails(tip: $tip)';
}


}

/// @nodoc
abstract mixin class $PaymentIntentAmountDetailsCopyWith<$Res>  {
  factory $PaymentIntentAmountDetailsCopyWith(PaymentIntentAmountDetails value, $Res Function(PaymentIntentAmountDetails) _then) = _$PaymentIntentAmountDetailsCopyWithImpl;
@useResult
$Res call({
 PaymentIntentTip? tip
});


$PaymentIntentTipCopyWith<$Res>? get tip;

}
/// @nodoc
class _$PaymentIntentAmountDetailsCopyWithImpl<$Res>
    implements $PaymentIntentAmountDetailsCopyWith<$Res> {
  _$PaymentIntentAmountDetailsCopyWithImpl(this._self, this._then);

  final PaymentIntentAmountDetails _self;
  final $Res Function(PaymentIntentAmountDetails) _then;

/// Create a copy of PaymentIntentAmountDetails
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? tip = freezed,}) {
  return _then(_self.copyWith(
tip: freezed == tip ? _self.tip : tip // ignore: cast_nullable_to_non_nullable
as PaymentIntentTip?,
  ));
}
/// Create a copy of PaymentIntentAmountDetails
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PaymentIntentTipCopyWith<$Res>? get tip {
    if (_self.tip == null) {
    return null;
  }

  return $PaymentIntentTipCopyWith<$Res>(_self.tip!, (value) {
    return _then(_self.copyWith(tip: value));
  });
}
}


/// Adds pattern-matching-related methods to [PaymentIntentAmountDetails].
extension PaymentIntentAmountDetailsPatterns on PaymentIntentAmountDetails {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _PaymentIntentAmountDetails value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _PaymentIntentAmountDetails() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _PaymentIntentAmountDetails value)  $default,){
final _that = this;
switch (_that) {
case _PaymentIntentAmountDetails():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _PaymentIntentAmountDetails value)?  $default,){
final _that = this;
switch (_that) {
case _PaymentIntentAmountDetails() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( PaymentIntentTip? tip)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _PaymentIntentAmountDetails() when $default != null:
return $default(_that.tip);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( PaymentIntentTip? tip)  $default,) {final _that = this;
switch (_that) {
case _PaymentIntentAmountDetails():
return $default(_that.tip);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( PaymentIntentTip? tip)?  $default,) {final _that = this;
switch (_that) {
case _PaymentIntentAmountDetails() when $default != null:
return $default(_that.tip);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _PaymentIntentAmountDetails implements PaymentIntentAmountDetails {
  const _PaymentIntentAmountDetails({this.tip = const PaymentIntentTip()});
  factory _PaymentIntentAmountDetails.fromJson(Map<String, dynamic> json) => _$PaymentIntentAmountDetailsFromJson(json);

/// Details about items included in the amount
@override@JsonKey() final  PaymentIntentTip? tip;

/// Create a copy of PaymentIntentAmountDetails
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PaymentIntentAmountDetailsCopyWith<_PaymentIntentAmountDetails> get copyWith => __$PaymentIntentAmountDetailsCopyWithImpl<_PaymentIntentAmountDetails>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PaymentIntentAmountDetailsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PaymentIntentAmountDetails&&(identical(other.tip, tip) || other.tip == tip));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tip);

@override
String toString() {
  return 'PaymentIntentAmountDetails(tip: $tip)';
}


}

/// @nodoc
abstract mixin class _$PaymentIntentAmountDetailsCopyWith<$Res> implements $PaymentIntentAmountDetailsCopyWith<$Res> {
  factory _$PaymentIntentAmountDetailsCopyWith(_PaymentIntentAmountDetails value, $Res Function(_PaymentIntentAmountDetails) _then) = __$PaymentIntentAmountDetailsCopyWithImpl;
@override @useResult
$Res call({
 PaymentIntentTip? tip
});


@override $PaymentIntentTipCopyWith<$Res>? get tip;

}
/// @nodoc
class __$PaymentIntentAmountDetailsCopyWithImpl<$Res>
    implements _$PaymentIntentAmountDetailsCopyWith<$Res> {
  __$PaymentIntentAmountDetailsCopyWithImpl(this._self, this._then);

  final _PaymentIntentAmountDetails _self;
  final $Res Function(_PaymentIntentAmountDetails) _then;

/// Create a copy of PaymentIntentAmountDetails
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? tip = freezed,}) {
  return _then(_PaymentIntentAmountDetails(
tip: freezed == tip ? _self.tip : tip // ignore: cast_nullable_to_non_nullable
as PaymentIntentTip?,
  ));
}

/// Create a copy of PaymentIntentAmountDetails
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PaymentIntentTipCopyWith<$Res>? get tip {
    if (_self.tip == null) {
    return null;
  }

  return $PaymentIntentTipCopyWith<$Res>(_self.tip!, (value) {
    return _then(_self.copyWith(tip: value));
  });
}
}


/// @nodoc
mixin _$PaymentIntentTip {

/// Portion of the amount that corresponds to a tip.
 int? get amount;
/// Create a copy of PaymentIntentTip
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PaymentIntentTipCopyWith<PaymentIntentTip> get copyWith => _$PaymentIntentTipCopyWithImpl<PaymentIntentTip>(this as PaymentIntentTip, _$identity);

  /// Serializes this PaymentIntentTip to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PaymentIntentTip&&(identical(other.amount, amount) || other.amount == amount));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,amount);

@override
String toString() {
  return 'PaymentIntentTip(amount: $amount)';
}


}

/// @nodoc
abstract mixin class $PaymentIntentTipCopyWith<$Res>  {
  factory $PaymentIntentTipCopyWith(PaymentIntentTip value, $Res Function(PaymentIntentTip) _then) = _$PaymentIntentTipCopyWithImpl;
@useResult
$Res call({
 int? amount
});




}
/// @nodoc
class _$PaymentIntentTipCopyWithImpl<$Res>
    implements $PaymentIntentTipCopyWith<$Res> {
  _$PaymentIntentTipCopyWithImpl(this._self, this._then);

  final PaymentIntentTip _self;
  final $Res Function(PaymentIntentTip) _then;

/// Create a copy of PaymentIntentTip
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? amount = freezed,}) {
  return _then(_self.copyWith(
amount: freezed == amount ? _self.amount : amount // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}


/// Adds pattern-matching-related methods to [PaymentIntentTip].
extension PaymentIntentTipPatterns on PaymentIntentTip {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _PaymentIntentTip value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _PaymentIntentTip() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _PaymentIntentTip value)  $default,){
final _that = this;
switch (_that) {
case _PaymentIntentTip():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _PaymentIntentTip value)?  $default,){
final _that = this;
switch (_that) {
case _PaymentIntentTip() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( int? amount)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _PaymentIntentTip() when $default != null:
return $default(_that.amount);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( int? amount)  $default,) {final _that = this;
switch (_that) {
case _PaymentIntentTip():
return $default(_that.amount);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( int? amount)?  $default,) {final _that = this;
switch (_that) {
case _PaymentIntentTip() when $default != null:
return $default(_that.amount);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _PaymentIntentTip implements PaymentIntentTip {
  const _PaymentIntentTip({this.amount});
  factory _PaymentIntentTip.fromJson(Map<String, dynamic> json) => _$PaymentIntentTipFromJson(json);

/// Portion of the amount that corresponds to a tip.
@override final  int? amount;

/// Create a copy of PaymentIntentTip
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PaymentIntentTipCopyWith<_PaymentIntentTip> get copyWith => __$PaymentIntentTipCopyWithImpl<_PaymentIntentTip>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PaymentIntentTipToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PaymentIntentTip&&(identical(other.amount, amount) || other.amount == amount));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,amount);

@override
String toString() {
  return 'PaymentIntentTip(amount: $amount)';
}


}

/// @nodoc
abstract mixin class _$PaymentIntentTipCopyWith<$Res> implements $PaymentIntentTipCopyWith<$Res> {
  factory _$PaymentIntentTipCopyWith(_PaymentIntentTip value, $Res Function(_PaymentIntentTip) _then) = __$PaymentIntentTipCopyWithImpl;
@override @useResult
$Res call({
 int? amount
});




}
/// @nodoc
class __$PaymentIntentTipCopyWithImpl<$Res>
    implements _$PaymentIntentTipCopyWith<$Res> {
  __$PaymentIntentTipCopyWithImpl(this._self, this._then);

  final _PaymentIntentTip _self;
  final $Res Function(_PaymentIntentTip) _then;

/// Create a copy of PaymentIntentTip
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? amount = freezed,}) {
  return _then(_PaymentIntentTip(
amount: freezed == amount ? _self.amount : amount // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}


/// @nodoc
mixin _$PaymentIntentAutomaticPaymentMethods {

/// Automatically calculates compatible payment methods
 bool? get enabled;
/// Create a copy of PaymentIntentAutomaticPaymentMethods
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PaymentIntentAutomaticPaymentMethodsCopyWith<PaymentIntentAutomaticPaymentMethods> get copyWith => _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<PaymentIntentAutomaticPaymentMethods>(this as PaymentIntentAutomaticPaymentMethods, _$identity);

  /// Serializes this PaymentIntentAutomaticPaymentMethods to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PaymentIntentAutomaticPaymentMethods&&(identical(other.enabled, enabled) || other.enabled == enabled));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,enabled);

@override
String toString() {
  return 'PaymentIntentAutomaticPaymentMethods(enabled: $enabled)';
}


}

/// @nodoc
abstract mixin class $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>  {
  factory $PaymentIntentAutomaticPaymentMethodsCopyWith(PaymentIntentAutomaticPaymentMethods value, $Res Function(PaymentIntentAutomaticPaymentMethods) _then) = _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl;
@useResult
$Res call({
 bool? enabled
});




}
/// @nodoc
class _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<$Res>
    implements $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl(this._self, this._then);

  final PaymentIntentAutomaticPaymentMethods _self;
  final $Res Function(PaymentIntentAutomaticPaymentMethods) _then;

/// Create a copy of PaymentIntentAutomaticPaymentMethods
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? enabled = freezed,}) {
  return _then(_self.copyWith(
enabled: freezed == enabled ? _self.enabled : enabled // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}


/// Adds pattern-matching-related methods to [PaymentIntentAutomaticPaymentMethods].
extension PaymentIntentAutomaticPaymentMethodsPatterns on PaymentIntentAutomaticPaymentMethods {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _PaymentIntentAutomaticPaymentMethods value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _PaymentIntentAutomaticPaymentMethods() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _PaymentIntentAutomaticPaymentMethods value)  $default,){
final _that = this;
switch (_that) {
case _PaymentIntentAutomaticPaymentMethods():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _PaymentIntentAutomaticPaymentMethods value)?  $default,){
final _that = this;
switch (_that) {
case _PaymentIntentAutomaticPaymentMethods() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( bool? enabled)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _PaymentIntentAutomaticPaymentMethods() when $default != null:
return $default(_that.enabled);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( bool? enabled)  $default,) {final _that = this;
switch (_that) {
case _PaymentIntentAutomaticPaymentMethods():
return $default(_that.enabled);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( bool? enabled)?  $default,) {final _that = this;
switch (_that) {
case _PaymentIntentAutomaticPaymentMethods() when $default != null:
return $default(_that.enabled);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _PaymentIntentAutomaticPaymentMethods implements PaymentIntentAutomaticPaymentMethods {
  const _PaymentIntentAutomaticPaymentMethods({required this.enabled});
  factory _PaymentIntentAutomaticPaymentMethods.fromJson(Map<String, dynamic> json) => _$PaymentIntentAutomaticPaymentMethodsFromJson(json);

/// Automatically calculates compatible payment methods
@override final  bool? enabled;

/// Create a copy of PaymentIntentAutomaticPaymentMethods
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PaymentIntentAutomaticPaymentMethodsCopyWith<_PaymentIntentAutomaticPaymentMethods> get copyWith => __$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<_PaymentIntentAutomaticPaymentMethods>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PaymentIntentAutomaticPaymentMethodsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PaymentIntentAutomaticPaymentMethods&&(identical(other.enabled, enabled) || other.enabled == enabled));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,enabled);

@override
String toString() {
  return 'PaymentIntentAutomaticPaymentMethods(enabled: $enabled)';
}


}

/// @nodoc
abstract mixin class _$PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> implements $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  factory _$PaymentIntentAutomaticPaymentMethodsCopyWith(_PaymentIntentAutomaticPaymentMethods value, $Res Function(_PaymentIntentAutomaticPaymentMethods) _then) = __$PaymentIntentAutomaticPaymentMethodsCopyWithImpl;
@override @useResult
$Res call({
 bool? enabled
});




}
/// @nodoc
class __$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<$Res>
    implements _$PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  __$PaymentIntentAutomaticPaymentMethodsCopyWithImpl(this._self, this._then);

  final _PaymentIntentAutomaticPaymentMethods _self;
  final $Res Function(_PaymentIntentAutomaticPaymentMethods) _then;

/// Create a copy of PaymentIntentAutomaticPaymentMethods
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? enabled = freezed,}) {
  return _then(_PaymentIntentAutomaticPaymentMethods(
enabled: freezed == enabled ? _self.enabled : enabled // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}

// dart format on
