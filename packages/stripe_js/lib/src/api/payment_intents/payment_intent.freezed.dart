// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'payment_intent.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PaymentIntent {
  /// Unique identifier for the object.
  String get id;

  /// String representing the object’s type.
  /// Objects of the same type share the same value.
  /// Value is "payment_intent".
  String get object;

  /// Amount intended to be collected by this PaymentIntent.
  /// A positive integer representing how much to charge in the
  /// smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to
  /// charge ¥100, a zero-decimal currency).
  /// The minimum amount is $0.50 US or equivalent in charge currency.
  /// The amount value supports up to eight digits
  /// (e.g., a value of 99999999 for a USD charge of $999,999.99).
  int get amount;

  /// The amount that can be captured with from this PaymentIntent (in cents).
  @JsonKey(name: "amount_capturable")
  int? get amountCapturable;

  /// Details about items included in the amount
  @JsonKey(name: "amount_details")
  PaymentIntentAmountDetails? get amountDetails;

  /// The amount that was collected from this PaymentIntent (in cents).
  @JsonKey(name: "amount_received")
  int? get amountReceived;

  /// CONNECT ONLY
  /// ID of the Connect application that created the PaymentIntent.
  String? get application;

  /// CONNECT ONLY
  /// The amount of the application fee (if any) that will be requested to
  /// be applied to the payment and transferred to the application owner’s
  /// Stripe account. The amount of the application fee collected will be
  /// capped at the total payment amount.
  /// For more information, see the PaymentIntents use
  /// case for connected accounts..
  @JsonKey(name: "application_fee_amount")
  int? get applicationFeeAmount;

  /// Settings to configure compatible payment methods from the
  /// Stripe Dashboard
  @JsonKey(name: "automatic_payment_methods")
  PaymentIntentAutomaticPaymentMethods? get automaticPaymentMethods;

  /// Populated when status is canceled, this is the time at which the
  /// PaymentIntent was canceled. Measured in seconds since the Unix epoch.
  @JsonKey(name: "canceled_at")
  int? get canceledAt;

  /// Reason for cancellation of this PaymentIntent,
  /// either user-provided
  /// (duplicate, fraudulent, requested_by_customer, or abandoned) or
  /// generated by Stripe internally
  /// (failed_invoice, void_invoice, or automatic).
  @JsonKey(name: "cancellation_reason")
  PaymentIntentCancellationReason? get cancellationReason;

  /// The client secret of this PaymentIntent. Used for client-side retrieval
  /// using a publishable key.
  /// The client secret can be used to complete a payment from your frontend.
  /// It should not be stored, logged, or exposed to anyone other than the
  /// customer. Make sure that you have TLS enabled on any page that includes
  /// the client secret.
  ///
  /// Refer to our docs to accept a payment and learn about how `client_secret`
  /// should be handled.
  @JsonKey(name: "client_secret")
  String get clientSecret;

  /// Controls when the funds will be captured from the customer’s account.
  @JsonKey(name: "capture_method")
  PaymentIntentCaptureMethod get captureMethod;
  @JsonKey(name: "confirmation_method")
  PaymentIntentConfirmationMethod get confirmationMethod;

  /// Time at which the object was created. Measured in seconds since the
  /// Unix epoch.
  int? get created;

  /// Three-letter ISO currency code, in lowercase. Must be a supported
  /// currency.
  String get currency;

  /// ID of the Customer this PaymentIntent belongs to, if one exists.
  /// Payment methods attached to other Customers cannot be used with this
  /// PaymentIntent.
  ///
  /// If present in combination with setup_future_usage,
  /// this PaymentIntent’s payment method will be attached to the
  /// Customer after the PaymentIntent has been confirmed and any
  /// required actions from the user are complete.
  String? get customer;

  /// An arbitrary string attached to the object.
  /// Often useful for displaying to users.
  String? get description;

  /// ID of the invoice that created this PaymentIntent, if it exists.
  String? get invoice;

  /// The payment error encountered in the previous PaymentIntent confirmation.
  /// It will be cleared if the PaymentIntent is later updated for any reason.
  @JsonKey(name: "last_payment_error")
  StripeError? get lastPaymentError;

  /// The latest charge created by this payment intent.
  @JsonKey(name: "latest_charge")
  String? get latestCharge;

  /// Has the value true if the object exists in live mode or the
  /// value false if the object exists in test mode.
  bool get livemode;

  /// Set of key-value pairs that you can attach to an object.
  /// This can be useful for storing additional information about the
  /// object in a structured format.
  Map<String, dynamic> get metadata;

  /// If present, this property tells you what actions you need to
  /// take in order for your customer to fulfill a payment using the
  /// provided source.
  @JsonKey(name: "next_action")
  dynamic get nextAction;

  /// CONNECT ONLY
  /// The account (if any) for which the funds of the PaymentIntent are
  /// intended. See the PaymentIntents use case for connected accounts
  /// for details.
  @JsonKey(name: "on_behalf_of")
  String? get onBehalfOf;

  /// ID of the payment method used in this PaymentIntent.
  @JsonKey(name: "payment_method")
  String? get paymentMethod;

  /// Payment-method-specific configuration for this PaymentIntent.
  @JsonKey(name: "payment_method_options")
  Map<dynamic, dynamic> get paymentMethodOptions;

  /// The list of payment method types (e.g. card) that this PaymentIntent
  /// is allowed to use.
  @JsonKey(
      name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown)
  List<PaymentMethodType> get paymentMethodTypes;

  /// If present, this property tells you about the processing state of the payment.
  dynamic get processing;

  /// Email address that the receipt for the resulting payment will be sent to.
  /// If receipt_email is specified for a payment in live mode, a receipt
  /// will be sent regardless of your email settings.
  @JsonKey(name: "receipt_email")
  String?
      get receiptEmail; // ID of the review associated with this PaymentIntent, if any.
  String? get review;

  /// Indicates that you intend to make future payments with this
  /// PaymentIntent’s payment method.
  /// Providing this parameter will attach the payment method to the
  /// PaymentIntent’s Customer, if present, after the PaymentIntent is
  /// confirmed and any required actions from the user are complete. I
  /// If no Customer was provided, the payment method can still be attached to
  /// a Customer after the transaction completes.
  /// When processing card payments, Stripe also uses setup_future_usage
  /// to dynamically optimize your payment flow and comply with regional
  /// legislation and network rules, such as SCA.
  @JsonKey(name: "setup_future_usage")
  PaymentIntentSetupFutureUsage? get setupFutureUsage;

  /// Shipping information for this PaymentIntent.
  ShippingDetails? get shipping;

  /// For non-card charges, you can use this value as the complete
  /// description that appears on your customers’ statements.
  /// Must contain at least one letter, maximum 22 characters.
  @JsonKey(name: "statement_descriptor")
  String? get statementDescriptor;

  /// Provides information about a card payment that customers see on
  /// their statements.
  /// Concatenated with the prefix (shortened descriptor) or statement
  /// descriptor that’s set on the account to form the complete statement
  /// descriptor. Maximum 22 characters for the concatenated descriptor.
  @JsonKey(name: "statement_descriptor_suffix")
  String? get statementDescriptorSuffix;

  /// Status of this PaymentIntent, one of requires_payment_method,
  /// requires_confirmation, requires_action, processing, requires_capture,
  /// canceled, or succeeded.
  PaymentIntentsStatus get status;

  /// CONNECT ONLY
  /// The data with which to automatically create a Transfer when the payment
  /// is finalized. See the PaymentIntents use case for connected
  /// accounts for details.
  @JsonKey(name: "transfer_data")
  dynamic get transferData;

  /// CONNECT ONLY
  /// A string that identifies the resulting payment as part of a group.
  /// See the PaymentIntents use case for connected accounts for details.
  @JsonKey(name: "transfer_group")
  dynamic get transferGroup;

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PaymentIntentCopyWith<PaymentIntent> get copyWith =>
      _$PaymentIntentCopyWithImpl<PaymentIntent>(
          this as PaymentIntent, _$identity);

  /// Serializes this PaymentIntent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PaymentIntent &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.amountCapturable, amountCapturable) ||
                other.amountCapturable == amountCapturable) &&
            (identical(other.amountDetails, amountDetails) ||
                other.amountDetails == amountDetails) &&
            (identical(other.amountReceived, amountReceived) ||
                other.amountReceived == amountReceived) &&
            (identical(other.application, application) ||
                other.application == application) &&
            (identical(other.applicationFeeAmount, applicationFeeAmount) ||
                other.applicationFeeAmount == applicationFeeAmount) &&
            (identical(other.automaticPaymentMethods, automaticPaymentMethods) ||
                other.automaticPaymentMethods == automaticPaymentMethods) &&
            (identical(other.canceledAt, canceledAt) ||
                other.canceledAt == canceledAt) &&
            (identical(other.cancellationReason, cancellationReason) ||
                other.cancellationReason == cancellationReason) &&
            (identical(other.clientSecret, clientSecret) ||
                other.clientSecret == clientSecret) &&
            (identical(other.captureMethod, captureMethod) ||
                other.captureMethod == captureMethod) &&
            (identical(other.confirmationMethod, confirmationMethod) ||
                other.confirmationMethod == confirmationMethod) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.currency, currency) ||
                other.currency == currency) &&
            (identical(other.customer, customer) ||
                other.customer == customer) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.invoice, invoice) || other.invoice == invoice) &&
            (identical(other.lastPaymentError, lastPaymentError) ||
                other.lastPaymentError == lastPaymentError) &&
            (identical(other.latestCharge, latestCharge) ||
                other.latestCharge == latestCharge) &&
            (identical(other.livemode, livemode) ||
                other.livemode == livemode) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            const DeepCollectionEquality()
                .equals(other.nextAction, nextAction) &&
            (identical(other.onBehalfOf, onBehalfOf) ||
                other.onBehalfOf == onBehalfOf) &&
            (identical(other.paymentMethod, paymentMethod) ||
                other.paymentMethod == paymentMethod) &&
            const DeepCollectionEquality()
                .equals(other.paymentMethodOptions, paymentMethodOptions) &&
            const DeepCollectionEquality()
                .equals(other.paymentMethodTypes, paymentMethodTypes) &&
            const DeepCollectionEquality()
                .equals(other.processing, processing) &&
            (identical(other.receiptEmail, receiptEmail) ||
                other.receiptEmail == receiptEmail) &&
            (identical(other.review, review) || other.review == review) &&
            (identical(other.setupFutureUsage, setupFutureUsage) ||
                other.setupFutureUsage == setupFutureUsage) &&
            (identical(other.shipping, shipping) ||
                other.shipping == shipping) &&
            (identical(other.statementDescriptor, statementDescriptor) ||
                other.statementDescriptor == statementDescriptor) &&
            (identical(other.statementDescriptorSuffix,
                    statementDescriptorSuffix) ||
                other.statementDescriptorSuffix == statementDescriptorSuffix) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality()
                .equals(other.transferData, transferData) &&
            const DeepCollectionEquality()
                .equals(other.transferGroup, transferGroup));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        amount,
        amountCapturable,
        amountDetails,
        amountReceived,
        application,
        applicationFeeAmount,
        automaticPaymentMethods,
        canceledAt,
        cancellationReason,
        clientSecret,
        captureMethod,
        confirmationMethod,
        created,
        currency,
        customer,
        description,
        invoice,
        lastPaymentError,
        latestCharge,
        livemode,
        const DeepCollectionEquality().hash(metadata),
        const DeepCollectionEquality().hash(nextAction),
        onBehalfOf,
        paymentMethod,
        const DeepCollectionEquality().hash(paymentMethodOptions),
        const DeepCollectionEquality().hash(paymentMethodTypes),
        const DeepCollectionEquality().hash(processing),
        receiptEmail,
        review,
        setupFutureUsage,
        shipping,
        statementDescriptor,
        statementDescriptorSuffix,
        status,
        const DeepCollectionEquality().hash(transferData),
        const DeepCollectionEquality().hash(transferGroup)
      ]);

  @override
  String toString() {
    return 'PaymentIntent(id: $id, object: $object, amount: $amount, amountCapturable: $amountCapturable, amountDetails: $amountDetails, amountReceived: $amountReceived, application: $application, applicationFeeAmount: $applicationFeeAmount, automaticPaymentMethods: $automaticPaymentMethods, canceledAt: $canceledAt, cancellationReason: $cancellationReason, clientSecret: $clientSecret, captureMethod: $captureMethod, confirmationMethod: $confirmationMethod, created: $created, currency: $currency, customer: $customer, description: $description, invoice: $invoice, lastPaymentError: $lastPaymentError, latestCharge: $latestCharge, livemode: $livemode, metadata: $metadata, nextAction: $nextAction, onBehalfOf: $onBehalfOf, paymentMethod: $paymentMethod, paymentMethodOptions: $paymentMethodOptions, paymentMethodTypes: $paymentMethodTypes, processing: $processing, receiptEmail: $receiptEmail, review: $review, setupFutureUsage: $setupFutureUsage, shipping: $shipping, statementDescriptor: $statementDescriptor, statementDescriptorSuffix: $statementDescriptorSuffix, status: $status, transferData: $transferData, transferGroup: $transferGroup)';
  }
}

/// @nodoc
abstract mixin class $PaymentIntentCopyWith<$Res> {
  factory $PaymentIntentCopyWith(
          PaymentIntent value, $Res Function(PaymentIntent) _then) =
      _$PaymentIntentCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      String object,
      int amount,
      @JsonKey(name: "amount_capturable") int? amountCapturable,
      @JsonKey(name: "amount_details")
      PaymentIntentAmountDetails? amountDetails,
      @JsonKey(name: "amount_received") int? amountReceived,
      String? application,
      @JsonKey(name: "application_fee_amount") int? applicationFeeAmount,
      @JsonKey(name: "automatic_payment_methods")
      PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods,
      @JsonKey(name: "canceled_at") int? canceledAt,
      @JsonKey(name: "cancellation_reason")
      PaymentIntentCancellationReason? cancellationReason,
      @JsonKey(name: "client_secret") String clientSecret,
      @JsonKey(name: "capture_method") PaymentIntentCaptureMethod captureMethod,
      @JsonKey(name: "confirmation_method")
      PaymentIntentConfirmationMethod confirmationMethod,
      int? created,
      String currency,
      String? customer,
      String? description,
      String? invoice,
      @JsonKey(name: "last_payment_error") StripeError? lastPaymentError,
      @JsonKey(name: "latest_charge") String? latestCharge,
      bool livemode,
      Map<String, dynamic> metadata,
      @JsonKey(name: "next_action") dynamic nextAction,
      @JsonKey(name: "on_behalf_of") String? onBehalfOf,
      @JsonKey(name: "payment_method") String? paymentMethod,
      @JsonKey(name: "payment_method_options")
      Map<dynamic, dynamic> paymentMethodOptions,
      @JsonKey(
          name: "payment_method_types",
          unknownEnumValue: PaymentMethodType.unknown)
      List<PaymentMethodType> paymentMethodTypes,
      dynamic processing,
      @JsonKey(name: "receipt_email") String? receiptEmail,
      String? review,
      @JsonKey(name: "setup_future_usage")
      PaymentIntentSetupFutureUsage? setupFutureUsage,
      ShippingDetails? shipping,
      @JsonKey(name: "statement_descriptor") String? statementDescriptor,
      @JsonKey(name: "statement_descriptor_suffix")
      String? statementDescriptorSuffix,
      PaymentIntentsStatus status,
      @JsonKey(name: "transfer_data") dynamic transferData,
      @JsonKey(name: "transfer_group") dynamic transferGroup});

  $PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails;
  $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>?
      get automaticPaymentMethods;
  $StripeErrorCopyWith<$Res>? get lastPaymentError;
  $ShippingDetailsCopyWith<$Res>? get shipping;
}

/// @nodoc
class _$PaymentIntentCopyWithImpl<$Res>
    implements $PaymentIntentCopyWith<$Res> {
  _$PaymentIntentCopyWithImpl(this._self, this._then);

  final PaymentIntent _self;
  final $Res Function(PaymentIntent) _then;

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? amount = null,
    Object? amountCapturable = freezed,
    Object? amountDetails = freezed,
    Object? amountReceived = freezed,
    Object? application = freezed,
    Object? applicationFeeAmount = freezed,
    Object? automaticPaymentMethods = freezed,
    Object? canceledAt = freezed,
    Object? cancellationReason = freezed,
    Object? clientSecret = null,
    Object? captureMethod = null,
    Object? confirmationMethod = null,
    Object? created = freezed,
    Object? currency = null,
    Object? customer = freezed,
    Object? description = freezed,
    Object? invoice = freezed,
    Object? lastPaymentError = freezed,
    Object? latestCharge = freezed,
    Object? livemode = null,
    Object? metadata = null,
    Object? nextAction = freezed,
    Object? onBehalfOf = freezed,
    Object? paymentMethod = freezed,
    Object? paymentMethodOptions = null,
    Object? paymentMethodTypes = null,
    Object? processing = freezed,
    Object? receiptEmail = freezed,
    Object? review = freezed,
    Object? setupFutureUsage = freezed,
    Object? shipping = freezed,
    Object? statementDescriptor = freezed,
    Object? statementDescriptorSuffix = freezed,
    Object? status = null,
    Object? transferData = freezed,
    Object? transferGroup = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _self.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int,
      amountCapturable: freezed == amountCapturable
          ? _self.amountCapturable
          : amountCapturable // ignore: cast_nullable_to_non_nullable
              as int?,
      amountDetails: freezed == amountDetails
          ? _self.amountDetails
          : amountDetails // ignore: cast_nullable_to_non_nullable
              as PaymentIntentAmountDetails?,
      amountReceived: freezed == amountReceived
          ? _self.amountReceived
          : amountReceived // ignore: cast_nullable_to_non_nullable
              as int?,
      application: freezed == application
          ? _self.application
          : application // ignore: cast_nullable_to_non_nullable
              as String?,
      applicationFeeAmount: freezed == applicationFeeAmount
          ? _self.applicationFeeAmount
          : applicationFeeAmount // ignore: cast_nullable_to_non_nullable
              as int?,
      automaticPaymentMethods: freezed == automaticPaymentMethods
          ? _self.automaticPaymentMethods
          : automaticPaymentMethods // ignore: cast_nullable_to_non_nullable
              as PaymentIntentAutomaticPaymentMethods?,
      canceledAt: freezed == canceledAt
          ? _self.canceledAt
          : canceledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancellationReason: freezed == cancellationReason
          ? _self.cancellationReason
          : cancellationReason // ignore: cast_nullable_to_non_nullable
              as PaymentIntentCancellationReason?,
      clientSecret: null == clientSecret
          ? _self.clientSecret
          : clientSecret // ignore: cast_nullable_to_non_nullable
              as String,
      captureMethod: null == captureMethod
          ? _self.captureMethod
          : captureMethod // ignore: cast_nullable_to_non_nullable
              as PaymentIntentCaptureMethod,
      confirmationMethod: null == confirmationMethod
          ? _self.confirmationMethod
          : confirmationMethod // ignore: cast_nullable_to_non_nullable
              as PaymentIntentConfirmationMethod,
      created: freezed == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      currency: null == currency
          ? _self.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String,
      customer: freezed == customer
          ? _self.customer
          : customer // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      invoice: freezed == invoice
          ? _self.invoice
          : invoice // ignore: cast_nullable_to_non_nullable
              as String?,
      lastPaymentError: freezed == lastPaymentError
          ? _self.lastPaymentError
          : lastPaymentError // ignore: cast_nullable_to_non_nullable
              as StripeError?,
      latestCharge: freezed == latestCharge
          ? _self.latestCharge
          : latestCharge // ignore: cast_nullable_to_non_nullable
              as String?,
      livemode: null == livemode
          ? _self.livemode
          : livemode // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      nextAction: freezed == nextAction
          ? _self.nextAction
          : nextAction // ignore: cast_nullable_to_non_nullable
              as dynamic,
      onBehalfOf: freezed == onBehalfOf
          ? _self.onBehalfOf
          : onBehalfOf // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentMethod: freezed == paymentMethod
          ? _self.paymentMethod
          : paymentMethod // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentMethodOptions: null == paymentMethodOptions
          ? _self.paymentMethodOptions
          : paymentMethodOptions // ignore: cast_nullable_to_non_nullable
              as Map<dynamic, dynamic>,
      paymentMethodTypes: null == paymentMethodTypes
          ? _self.paymentMethodTypes
          : paymentMethodTypes // ignore: cast_nullable_to_non_nullable
              as List<PaymentMethodType>,
      processing: freezed == processing
          ? _self.processing
          : processing // ignore: cast_nullable_to_non_nullable
              as dynamic,
      receiptEmail: freezed == receiptEmail
          ? _self.receiptEmail
          : receiptEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      review: freezed == review
          ? _self.review
          : review // ignore: cast_nullable_to_non_nullable
              as String?,
      setupFutureUsage: freezed == setupFutureUsage
          ? _self.setupFutureUsage
          : setupFutureUsage // ignore: cast_nullable_to_non_nullable
              as PaymentIntentSetupFutureUsage?,
      shipping: freezed == shipping
          ? _self.shipping
          : shipping // ignore: cast_nullable_to_non_nullable
              as ShippingDetails?,
      statementDescriptor: freezed == statementDescriptor
          ? _self.statementDescriptor
          : statementDescriptor // ignore: cast_nullable_to_non_nullable
              as String?,
      statementDescriptorSuffix: freezed == statementDescriptorSuffix
          ? _self.statementDescriptorSuffix
          : statementDescriptorSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as PaymentIntentsStatus,
      transferData: freezed == transferData
          ? _self.transferData
          : transferData // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transferGroup: freezed == transferGroup
          ? _self.transferGroup
          : transferGroup // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails {
    if (_self.amountDetails == null) {
      return null;
    }

    return $PaymentIntentAmountDetailsCopyWith<$Res>(_self.amountDetails!,
        (value) {
      return _then(_self.copyWith(amountDetails: value));
    });
  }

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>?
      get automaticPaymentMethods {
    if (_self.automaticPaymentMethods == null) {
      return null;
    }

    return $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>(
        _self.automaticPaymentMethods!, (value) {
      return _then(_self.copyWith(automaticPaymentMethods: value));
    });
  }

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StripeErrorCopyWith<$Res>? get lastPaymentError {
    if (_self.lastPaymentError == null) {
      return null;
    }

    return $StripeErrorCopyWith<$Res>(_self.lastPaymentError!, (value) {
      return _then(_self.copyWith(lastPaymentError: value));
    });
  }

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ShippingDetailsCopyWith<$Res>? get shipping {
    if (_self.shipping == null) {
      return null;
    }

    return $ShippingDetailsCopyWith<$Res>(_self.shipping!, (value) {
      return _then(_self.copyWith(shipping: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _PaymentIntent implements PaymentIntent {
  const _PaymentIntent(
      {required this.id,
      this.object = "payment_intent",
      required this.amount,
      @JsonKey(name: "amount_capturable") this.amountCapturable,
      @JsonKey(name: "amount_details")
      this.amountDetails = const PaymentIntentAmountDetails(),
      @JsonKey(name: "amount_received") this.amountReceived,
      this.application,
      @JsonKey(name: "application_fee_amount") this.applicationFeeAmount,
      @JsonKey(name: "automatic_payment_methods") this.automaticPaymentMethods,
      @JsonKey(name: "canceled_at") this.canceledAt,
      @JsonKey(name: "cancellation_reason") this.cancellationReason,
      @JsonKey(name: "client_secret") required this.clientSecret,
      @JsonKey(name: "capture_method")
      this.captureMethod = PaymentIntentCaptureMethod.automatic,
      @JsonKey(name: "confirmation_method")
      this.confirmationMethod = PaymentIntentConfirmationMethod.automatic,
      this.created,
      required this.currency,
      this.customer,
      this.description,
      this.invoice,
      @JsonKey(name: "last_payment_error") this.lastPaymentError,
      @JsonKey(name: "latest_charge") this.latestCharge,
      required this.livemode,
      final Map<String, dynamic> metadata = const {},
      @JsonKey(name: "next_action") this.nextAction,
      @JsonKey(name: "on_behalf_of") this.onBehalfOf,
      @JsonKey(name: "payment_method") this.paymentMethod,
      @JsonKey(name: "payment_method_options")
      final Map<dynamic, dynamic> paymentMethodOptions = const {},
      @JsonKey(
          name: "payment_method_types",
          unknownEnumValue: PaymentMethodType.unknown)
      final List<PaymentMethodType> paymentMethodTypes = const [],
      this.processing,
      @JsonKey(name: "receipt_email") this.receiptEmail,
      this.review,
      @JsonKey(name: "setup_future_usage") this.setupFutureUsage,
      this.shipping,
      @JsonKey(name: "statement_descriptor") this.statementDescriptor,
      @JsonKey(name: "statement_descriptor_suffix")
      this.statementDescriptorSuffix,
      required this.status,
      @JsonKey(name: "transfer_data") this.transferData,
      @JsonKey(name: "transfer_group") this.transferGroup})
      : _metadata = metadata,
        _paymentMethodOptions = paymentMethodOptions,
        _paymentMethodTypes = paymentMethodTypes;
  factory _PaymentIntent.fromJson(Map<String, dynamic> json) =>
      _$PaymentIntentFromJson(json);

  /// Unique identifier for the object.
  @override
  final String id;

  /// String representing the object’s type.
  /// Objects of the same type share the same value.
  /// Value is "payment_intent".
  @override
  @JsonKey()
  final String object;

  /// Amount intended to be collected by this PaymentIntent.
  /// A positive integer representing how much to charge in the
  /// smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to
  /// charge ¥100, a zero-decimal currency).
  /// The minimum amount is $0.50 US or equivalent in charge currency.
  /// The amount value supports up to eight digits
  /// (e.g., a value of 99999999 for a USD charge of $999,999.99).
  @override
  final int amount;

  /// The amount that can be captured with from this PaymentIntent (in cents).
  @override
  @JsonKey(name: "amount_capturable")
  final int? amountCapturable;

  /// Details about items included in the amount
  @override
  @JsonKey(name: "amount_details")
  final PaymentIntentAmountDetails? amountDetails;

  /// The amount that was collected from this PaymentIntent (in cents).
  @override
  @JsonKey(name: "amount_received")
  final int? amountReceived;

  /// CONNECT ONLY
  /// ID of the Connect application that created the PaymentIntent.
  @override
  final String? application;

  /// CONNECT ONLY
  /// The amount of the application fee (if any) that will be requested to
  /// be applied to the payment and transferred to the application owner’s
  /// Stripe account. The amount of the application fee collected will be
  /// capped at the total payment amount.
  /// For more information, see the PaymentIntents use
  /// case for connected accounts..
  @override
  @JsonKey(name: "application_fee_amount")
  final int? applicationFeeAmount;

  /// Settings to configure compatible payment methods from the
  /// Stripe Dashboard
  @override
  @JsonKey(name: "automatic_payment_methods")
  final PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods;

  /// Populated when status is canceled, this is the time at which the
  /// PaymentIntent was canceled. Measured in seconds since the Unix epoch.
  @override
  @JsonKey(name: "canceled_at")
  final int? canceledAt;

  /// Reason for cancellation of this PaymentIntent,
  /// either user-provided
  /// (duplicate, fraudulent, requested_by_customer, or abandoned) or
  /// generated by Stripe internally
  /// (failed_invoice, void_invoice, or automatic).
  @override
  @JsonKey(name: "cancellation_reason")
  final PaymentIntentCancellationReason? cancellationReason;

  /// The client secret of this PaymentIntent. Used for client-side retrieval
  /// using a publishable key.
  /// The client secret can be used to complete a payment from your frontend.
  /// It should not be stored, logged, or exposed to anyone other than the
  /// customer. Make sure that you have TLS enabled on any page that includes
  /// the client secret.
  ///
  /// Refer to our docs to accept a payment and learn about how `client_secret`
  /// should be handled.
  @override
  @JsonKey(name: "client_secret")
  final String clientSecret;

  /// Controls when the funds will be captured from the customer’s account.
  @override
  @JsonKey(name: "capture_method")
  final PaymentIntentCaptureMethod captureMethod;
  @override
  @JsonKey(name: "confirmation_method")
  final PaymentIntentConfirmationMethod confirmationMethod;

  /// Time at which the object was created. Measured in seconds since the
  /// Unix epoch.
  @override
  final int? created;

  /// Three-letter ISO currency code, in lowercase. Must be a supported
  /// currency.
  @override
  final String currency;

  /// ID of the Customer this PaymentIntent belongs to, if one exists.
  /// Payment methods attached to other Customers cannot be used with this
  /// PaymentIntent.
  ///
  /// If present in combination with setup_future_usage,
  /// this PaymentIntent’s payment method will be attached to the
  /// Customer after the PaymentIntent has been confirmed and any
  /// required actions from the user are complete.
  @override
  final String? customer;

  /// An arbitrary string attached to the object.
  /// Often useful for displaying to users.
  @override
  final String? description;

  /// ID of the invoice that created this PaymentIntent, if it exists.
  @override
  final String? invoice;

  /// The payment error encountered in the previous PaymentIntent confirmation.
  /// It will be cleared if the PaymentIntent is later updated for any reason.
  @override
  @JsonKey(name: "last_payment_error")
  final StripeError? lastPaymentError;

  /// The latest charge created by this payment intent.
  @override
  @JsonKey(name: "latest_charge")
  final String? latestCharge;

  /// Has the value true if the object exists in live mode or the
  /// value false if the object exists in test mode.
  @override
  final bool livemode;

  /// Set of key-value pairs that you can attach to an object.
  /// This can be useful for storing additional information about the
  /// object in a structured format.
  final Map<String, dynamic> _metadata;

  /// Set of key-value pairs that you can attach to an object.
  /// This can be useful for storing additional information about the
  /// object in a structured format.
  @override
  @JsonKey()
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  /// If present, this property tells you what actions you need to
  /// take in order for your customer to fulfill a payment using the
  /// provided source.
  @override
  @JsonKey(name: "next_action")
  final dynamic nextAction;

  /// CONNECT ONLY
  /// The account (if any) for which the funds of the PaymentIntent are
  /// intended. See the PaymentIntents use case for connected accounts
  /// for details.
  @override
  @JsonKey(name: "on_behalf_of")
  final String? onBehalfOf;

  /// ID of the payment method used in this PaymentIntent.
  @override
  @JsonKey(name: "payment_method")
  final String? paymentMethod;

  /// Payment-method-specific configuration for this PaymentIntent.
  final Map<dynamic, dynamic> _paymentMethodOptions;

  /// Payment-method-specific configuration for this PaymentIntent.
  @override
  @JsonKey(name: "payment_method_options")
  Map<dynamic, dynamic> get paymentMethodOptions {
    if (_paymentMethodOptions is EqualUnmodifiableMapView)
      return _paymentMethodOptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_paymentMethodOptions);
  }

  /// The list of payment method types (e.g. card) that this PaymentIntent
  /// is allowed to use.
  final List<PaymentMethodType> _paymentMethodTypes;

  /// The list of payment method types (e.g. card) that this PaymentIntent
  /// is allowed to use.
  @override
  @JsonKey(
      name: "payment_method_types", unknownEnumValue: PaymentMethodType.unknown)
  List<PaymentMethodType> get paymentMethodTypes {
    if (_paymentMethodTypes is EqualUnmodifiableListView)
      return _paymentMethodTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_paymentMethodTypes);
  }

  /// If present, this property tells you about the processing state of the payment.
  @override
  final dynamic processing;

  /// Email address that the receipt for the resulting payment will be sent to.
  /// If receipt_email is specified for a payment in live mode, a receipt
  /// will be sent regardless of your email settings.
  @override
  @JsonKey(name: "receipt_email")
  final String? receiptEmail;
// ID of the review associated with this PaymentIntent, if any.
  @override
  final String? review;

  /// Indicates that you intend to make future payments with this
  /// PaymentIntent’s payment method.
  /// Providing this parameter will attach the payment method to the
  /// PaymentIntent’s Customer, if present, after the PaymentIntent is
  /// confirmed and any required actions from the user are complete. I
  /// If no Customer was provided, the payment method can still be attached to
  /// a Customer after the transaction completes.
  /// When processing card payments, Stripe also uses setup_future_usage
  /// to dynamically optimize your payment flow and comply with regional
  /// legislation and network rules, such as SCA.
  @override
  @JsonKey(name: "setup_future_usage")
  final PaymentIntentSetupFutureUsage? setupFutureUsage;

  /// Shipping information for this PaymentIntent.
  @override
  final ShippingDetails? shipping;

  /// For non-card charges, you can use this value as the complete
  /// description that appears on your customers’ statements.
  /// Must contain at least one letter, maximum 22 characters.
  @override
  @JsonKey(name: "statement_descriptor")
  final String? statementDescriptor;

  /// Provides information about a card payment that customers see on
  /// their statements.
  /// Concatenated with the prefix (shortened descriptor) or statement
  /// descriptor that’s set on the account to form the complete statement
  /// descriptor. Maximum 22 characters for the concatenated descriptor.
  @override
  @JsonKey(name: "statement_descriptor_suffix")
  final String? statementDescriptorSuffix;

  /// Status of this PaymentIntent, one of requires_payment_method,
  /// requires_confirmation, requires_action, processing, requires_capture,
  /// canceled, or succeeded.
  @override
  final PaymentIntentsStatus status;

  /// CONNECT ONLY
  /// The data with which to automatically create a Transfer when the payment
  /// is finalized. See the PaymentIntents use case for connected
  /// accounts for details.
  @override
  @JsonKey(name: "transfer_data")
  final dynamic transferData;

  /// CONNECT ONLY
  /// A string that identifies the resulting payment as part of a group.
  /// See the PaymentIntents use case for connected accounts for details.
  @override
  @JsonKey(name: "transfer_group")
  final dynamic transferGroup;

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PaymentIntentCopyWith<_PaymentIntent> get copyWith =>
      __$PaymentIntentCopyWithImpl<_PaymentIntent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PaymentIntentToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PaymentIntent &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.amountCapturable, amountCapturable) ||
                other.amountCapturable == amountCapturable) &&
            (identical(other.amountDetails, amountDetails) ||
                other.amountDetails == amountDetails) &&
            (identical(other.amountReceived, amountReceived) ||
                other.amountReceived == amountReceived) &&
            (identical(other.application, application) ||
                other.application == application) &&
            (identical(other.applicationFeeAmount, applicationFeeAmount) ||
                other.applicationFeeAmount == applicationFeeAmount) &&
            (identical(other.automaticPaymentMethods, automaticPaymentMethods) ||
                other.automaticPaymentMethods == automaticPaymentMethods) &&
            (identical(other.canceledAt, canceledAt) ||
                other.canceledAt == canceledAt) &&
            (identical(other.cancellationReason, cancellationReason) ||
                other.cancellationReason == cancellationReason) &&
            (identical(other.clientSecret, clientSecret) ||
                other.clientSecret == clientSecret) &&
            (identical(other.captureMethod, captureMethod) ||
                other.captureMethod == captureMethod) &&
            (identical(other.confirmationMethod, confirmationMethod) ||
                other.confirmationMethod == confirmationMethod) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.currency, currency) ||
                other.currency == currency) &&
            (identical(other.customer, customer) ||
                other.customer == customer) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.invoice, invoice) || other.invoice == invoice) &&
            (identical(other.lastPaymentError, lastPaymentError) ||
                other.lastPaymentError == lastPaymentError) &&
            (identical(other.latestCharge, latestCharge) ||
                other.latestCharge == latestCharge) &&
            (identical(other.livemode, livemode) ||
                other.livemode == livemode) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            const DeepCollectionEquality()
                .equals(other.nextAction, nextAction) &&
            (identical(other.onBehalfOf, onBehalfOf) ||
                other.onBehalfOf == onBehalfOf) &&
            (identical(other.paymentMethod, paymentMethod) ||
                other.paymentMethod == paymentMethod) &&
            const DeepCollectionEquality()
                .equals(other._paymentMethodOptions, _paymentMethodOptions) &&
            const DeepCollectionEquality()
                .equals(other._paymentMethodTypes, _paymentMethodTypes) &&
            const DeepCollectionEquality()
                .equals(other.processing, processing) &&
            (identical(other.receiptEmail, receiptEmail) ||
                other.receiptEmail == receiptEmail) &&
            (identical(other.review, review) || other.review == review) &&
            (identical(other.setupFutureUsage, setupFutureUsage) ||
                other.setupFutureUsage == setupFutureUsage) &&
            (identical(other.shipping, shipping) ||
                other.shipping == shipping) &&
            (identical(other.statementDescriptor, statementDescriptor) ||
                other.statementDescriptor == statementDescriptor) &&
            (identical(other.statementDescriptorSuffix,
                    statementDescriptorSuffix) ||
                other.statementDescriptorSuffix == statementDescriptorSuffix) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality()
                .equals(other.transferData, transferData) &&
            const DeepCollectionEquality()
                .equals(other.transferGroup, transferGroup));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        amount,
        amountCapturable,
        amountDetails,
        amountReceived,
        application,
        applicationFeeAmount,
        automaticPaymentMethods,
        canceledAt,
        cancellationReason,
        clientSecret,
        captureMethod,
        confirmationMethod,
        created,
        currency,
        customer,
        description,
        invoice,
        lastPaymentError,
        latestCharge,
        livemode,
        const DeepCollectionEquality().hash(_metadata),
        const DeepCollectionEquality().hash(nextAction),
        onBehalfOf,
        paymentMethod,
        const DeepCollectionEquality().hash(_paymentMethodOptions),
        const DeepCollectionEquality().hash(_paymentMethodTypes),
        const DeepCollectionEquality().hash(processing),
        receiptEmail,
        review,
        setupFutureUsage,
        shipping,
        statementDescriptor,
        statementDescriptorSuffix,
        status,
        const DeepCollectionEquality().hash(transferData),
        const DeepCollectionEquality().hash(transferGroup)
      ]);

  @override
  String toString() {
    return 'PaymentIntent(id: $id, object: $object, amount: $amount, amountCapturable: $amountCapturable, amountDetails: $amountDetails, amountReceived: $amountReceived, application: $application, applicationFeeAmount: $applicationFeeAmount, automaticPaymentMethods: $automaticPaymentMethods, canceledAt: $canceledAt, cancellationReason: $cancellationReason, clientSecret: $clientSecret, captureMethod: $captureMethod, confirmationMethod: $confirmationMethod, created: $created, currency: $currency, customer: $customer, description: $description, invoice: $invoice, lastPaymentError: $lastPaymentError, latestCharge: $latestCharge, livemode: $livemode, metadata: $metadata, nextAction: $nextAction, onBehalfOf: $onBehalfOf, paymentMethod: $paymentMethod, paymentMethodOptions: $paymentMethodOptions, paymentMethodTypes: $paymentMethodTypes, processing: $processing, receiptEmail: $receiptEmail, review: $review, setupFutureUsage: $setupFutureUsage, shipping: $shipping, statementDescriptor: $statementDescriptor, statementDescriptorSuffix: $statementDescriptorSuffix, status: $status, transferData: $transferData, transferGroup: $transferGroup)';
  }
}

/// @nodoc
abstract mixin class _$PaymentIntentCopyWith<$Res>
    implements $PaymentIntentCopyWith<$Res> {
  factory _$PaymentIntentCopyWith(
          _PaymentIntent value, $Res Function(_PaymentIntent) _then) =
      __$PaymentIntentCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      String object,
      int amount,
      @JsonKey(name: "amount_capturable") int? amountCapturable,
      @JsonKey(name: "amount_details")
      PaymentIntentAmountDetails? amountDetails,
      @JsonKey(name: "amount_received") int? amountReceived,
      String? application,
      @JsonKey(name: "application_fee_amount") int? applicationFeeAmount,
      @JsonKey(name: "automatic_payment_methods")
      PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods,
      @JsonKey(name: "canceled_at") int? canceledAt,
      @JsonKey(name: "cancellation_reason")
      PaymentIntentCancellationReason? cancellationReason,
      @JsonKey(name: "client_secret") String clientSecret,
      @JsonKey(name: "capture_method") PaymentIntentCaptureMethod captureMethod,
      @JsonKey(name: "confirmation_method")
      PaymentIntentConfirmationMethod confirmationMethod,
      int? created,
      String currency,
      String? customer,
      String? description,
      String? invoice,
      @JsonKey(name: "last_payment_error") StripeError? lastPaymentError,
      @JsonKey(name: "latest_charge") String? latestCharge,
      bool livemode,
      Map<String, dynamic> metadata,
      @JsonKey(name: "next_action") dynamic nextAction,
      @JsonKey(name: "on_behalf_of") String? onBehalfOf,
      @JsonKey(name: "payment_method") String? paymentMethod,
      @JsonKey(name: "payment_method_options")
      Map<dynamic, dynamic> paymentMethodOptions,
      @JsonKey(
          name: "payment_method_types",
          unknownEnumValue: PaymentMethodType.unknown)
      List<PaymentMethodType> paymentMethodTypes,
      dynamic processing,
      @JsonKey(name: "receipt_email") String? receiptEmail,
      String? review,
      @JsonKey(name: "setup_future_usage")
      PaymentIntentSetupFutureUsage? setupFutureUsage,
      ShippingDetails? shipping,
      @JsonKey(name: "statement_descriptor") String? statementDescriptor,
      @JsonKey(name: "statement_descriptor_suffix")
      String? statementDescriptorSuffix,
      PaymentIntentsStatus status,
      @JsonKey(name: "transfer_data") dynamic transferData,
      @JsonKey(name: "transfer_group") dynamic transferGroup});

  @override
  $PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails;
  @override
  $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>?
      get automaticPaymentMethods;
  @override
  $StripeErrorCopyWith<$Res>? get lastPaymentError;
  @override
  $ShippingDetailsCopyWith<$Res>? get shipping;
}

/// @nodoc
class __$PaymentIntentCopyWithImpl<$Res>
    implements _$PaymentIntentCopyWith<$Res> {
  __$PaymentIntentCopyWithImpl(this._self, this._then);

  final _PaymentIntent _self;
  final $Res Function(_PaymentIntent) _then;

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? amount = null,
    Object? amountCapturable = freezed,
    Object? amountDetails = freezed,
    Object? amountReceived = freezed,
    Object? application = freezed,
    Object? applicationFeeAmount = freezed,
    Object? automaticPaymentMethods = freezed,
    Object? canceledAt = freezed,
    Object? cancellationReason = freezed,
    Object? clientSecret = null,
    Object? captureMethod = null,
    Object? confirmationMethod = null,
    Object? created = freezed,
    Object? currency = null,
    Object? customer = freezed,
    Object? description = freezed,
    Object? invoice = freezed,
    Object? lastPaymentError = freezed,
    Object? latestCharge = freezed,
    Object? livemode = null,
    Object? metadata = null,
    Object? nextAction = freezed,
    Object? onBehalfOf = freezed,
    Object? paymentMethod = freezed,
    Object? paymentMethodOptions = null,
    Object? paymentMethodTypes = null,
    Object? processing = freezed,
    Object? receiptEmail = freezed,
    Object? review = freezed,
    Object? setupFutureUsage = freezed,
    Object? shipping = freezed,
    Object? statementDescriptor = freezed,
    Object? statementDescriptorSuffix = freezed,
    Object? status = null,
    Object? transferData = freezed,
    Object? transferGroup = freezed,
  }) {
    return _then(_PaymentIntent(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _self.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int,
      amountCapturable: freezed == amountCapturable
          ? _self.amountCapturable
          : amountCapturable // ignore: cast_nullable_to_non_nullable
              as int?,
      amountDetails: freezed == amountDetails
          ? _self.amountDetails
          : amountDetails // ignore: cast_nullable_to_non_nullable
              as PaymentIntentAmountDetails?,
      amountReceived: freezed == amountReceived
          ? _self.amountReceived
          : amountReceived // ignore: cast_nullable_to_non_nullable
              as int?,
      application: freezed == application
          ? _self.application
          : application // ignore: cast_nullable_to_non_nullable
              as String?,
      applicationFeeAmount: freezed == applicationFeeAmount
          ? _self.applicationFeeAmount
          : applicationFeeAmount // ignore: cast_nullable_to_non_nullable
              as int?,
      automaticPaymentMethods: freezed == automaticPaymentMethods
          ? _self.automaticPaymentMethods
          : automaticPaymentMethods // ignore: cast_nullable_to_non_nullable
              as PaymentIntentAutomaticPaymentMethods?,
      canceledAt: freezed == canceledAt
          ? _self.canceledAt
          : canceledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancellationReason: freezed == cancellationReason
          ? _self.cancellationReason
          : cancellationReason // ignore: cast_nullable_to_non_nullable
              as PaymentIntentCancellationReason?,
      clientSecret: null == clientSecret
          ? _self.clientSecret
          : clientSecret // ignore: cast_nullable_to_non_nullable
              as String,
      captureMethod: null == captureMethod
          ? _self.captureMethod
          : captureMethod // ignore: cast_nullable_to_non_nullable
              as PaymentIntentCaptureMethod,
      confirmationMethod: null == confirmationMethod
          ? _self.confirmationMethod
          : confirmationMethod // ignore: cast_nullable_to_non_nullable
              as PaymentIntentConfirmationMethod,
      created: freezed == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      currency: null == currency
          ? _self.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String,
      customer: freezed == customer
          ? _self.customer
          : customer // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      invoice: freezed == invoice
          ? _self.invoice
          : invoice // ignore: cast_nullable_to_non_nullable
              as String?,
      lastPaymentError: freezed == lastPaymentError
          ? _self.lastPaymentError
          : lastPaymentError // ignore: cast_nullable_to_non_nullable
              as StripeError?,
      latestCharge: freezed == latestCharge
          ? _self.latestCharge
          : latestCharge // ignore: cast_nullable_to_non_nullable
              as String?,
      livemode: null == livemode
          ? _self.livemode
          : livemode // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      nextAction: freezed == nextAction
          ? _self.nextAction
          : nextAction // ignore: cast_nullable_to_non_nullable
              as dynamic,
      onBehalfOf: freezed == onBehalfOf
          ? _self.onBehalfOf
          : onBehalfOf // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentMethod: freezed == paymentMethod
          ? _self.paymentMethod
          : paymentMethod // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentMethodOptions: null == paymentMethodOptions
          ? _self._paymentMethodOptions
          : paymentMethodOptions // ignore: cast_nullable_to_non_nullable
              as Map<dynamic, dynamic>,
      paymentMethodTypes: null == paymentMethodTypes
          ? _self._paymentMethodTypes
          : paymentMethodTypes // ignore: cast_nullable_to_non_nullable
              as List<PaymentMethodType>,
      processing: freezed == processing
          ? _self.processing
          : processing // ignore: cast_nullable_to_non_nullable
              as dynamic,
      receiptEmail: freezed == receiptEmail
          ? _self.receiptEmail
          : receiptEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      review: freezed == review
          ? _self.review
          : review // ignore: cast_nullable_to_non_nullable
              as String?,
      setupFutureUsage: freezed == setupFutureUsage
          ? _self.setupFutureUsage
          : setupFutureUsage // ignore: cast_nullable_to_non_nullable
              as PaymentIntentSetupFutureUsage?,
      shipping: freezed == shipping
          ? _self.shipping
          : shipping // ignore: cast_nullable_to_non_nullable
              as ShippingDetails?,
      statementDescriptor: freezed == statementDescriptor
          ? _self.statementDescriptor
          : statementDescriptor // ignore: cast_nullable_to_non_nullable
              as String?,
      statementDescriptorSuffix: freezed == statementDescriptorSuffix
          ? _self.statementDescriptorSuffix
          : statementDescriptorSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as PaymentIntentsStatus,
      transferData: freezed == transferData
          ? _self.transferData
          : transferData // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transferGroup: freezed == transferGroup
          ? _self.transferGroup
          : transferGroup // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails {
    if (_self.amountDetails == null) {
      return null;
    }

    return $PaymentIntentAmountDetailsCopyWith<$Res>(_self.amountDetails!,
        (value) {
      return _then(_self.copyWith(amountDetails: value));
    });
  }

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>?
      get automaticPaymentMethods {
    if (_self.automaticPaymentMethods == null) {
      return null;
    }

    return $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>(
        _self.automaticPaymentMethods!, (value) {
      return _then(_self.copyWith(automaticPaymentMethods: value));
    });
  }

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StripeErrorCopyWith<$Res>? get lastPaymentError {
    if (_self.lastPaymentError == null) {
      return null;
    }

    return $StripeErrorCopyWith<$Res>(_self.lastPaymentError!, (value) {
      return _then(_self.copyWith(lastPaymentError: value));
    });
  }

  /// Create a copy of PaymentIntent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ShippingDetailsCopyWith<$Res>? get shipping {
    if (_self.shipping == null) {
      return null;
    }

    return $ShippingDetailsCopyWith<$Res>(_self.shipping!, (value) {
      return _then(_self.copyWith(shipping: value));
    });
  }
}

/// @nodoc
mixin _$PaymentIntentAmountDetails {
  /// Details about items included in the amount
  PaymentIntentTip? get tip;

  /// Create a copy of PaymentIntentAmountDetails
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PaymentIntentAmountDetailsCopyWith<PaymentIntentAmountDetails>
      get copyWith =>
          _$PaymentIntentAmountDetailsCopyWithImpl<PaymentIntentAmountDetails>(
              this as PaymentIntentAmountDetails, _$identity);

  /// Serializes this PaymentIntentAmountDetails to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PaymentIntentAmountDetails &&
            (identical(other.tip, tip) || other.tip == tip));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, tip);

  @override
  String toString() {
    return 'PaymentIntentAmountDetails(tip: $tip)';
  }
}

/// @nodoc
abstract mixin class $PaymentIntentAmountDetailsCopyWith<$Res> {
  factory $PaymentIntentAmountDetailsCopyWith(PaymentIntentAmountDetails value,
          $Res Function(PaymentIntentAmountDetails) _then) =
      _$PaymentIntentAmountDetailsCopyWithImpl;
  @useResult
  $Res call({PaymentIntentTip? tip});

  $PaymentIntentTipCopyWith<$Res>? get tip;
}

/// @nodoc
class _$PaymentIntentAmountDetailsCopyWithImpl<$Res>
    implements $PaymentIntentAmountDetailsCopyWith<$Res> {
  _$PaymentIntentAmountDetailsCopyWithImpl(this._self, this._then);

  final PaymentIntentAmountDetails _self;
  final $Res Function(PaymentIntentAmountDetails) _then;

  /// Create a copy of PaymentIntentAmountDetails
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tip = freezed,
  }) {
    return _then(_self.copyWith(
      tip: freezed == tip
          ? _self.tip
          : tip // ignore: cast_nullable_to_non_nullable
              as PaymentIntentTip?,
    ));
  }

  /// Create a copy of PaymentIntentAmountDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PaymentIntentTipCopyWith<$Res>? get tip {
    if (_self.tip == null) {
      return null;
    }

    return $PaymentIntentTipCopyWith<$Res>(_self.tip!, (value) {
      return _then(_self.copyWith(tip: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _PaymentIntentAmountDetails implements PaymentIntentAmountDetails {
  const _PaymentIntentAmountDetails({this.tip = const PaymentIntentTip()});
  factory _PaymentIntentAmountDetails.fromJson(Map<String, dynamic> json) =>
      _$PaymentIntentAmountDetailsFromJson(json);

  /// Details about items included in the amount
  @override
  @JsonKey()
  final PaymentIntentTip? tip;

  /// Create a copy of PaymentIntentAmountDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PaymentIntentAmountDetailsCopyWith<_PaymentIntentAmountDetails>
      get copyWith => __$PaymentIntentAmountDetailsCopyWithImpl<
          _PaymentIntentAmountDetails>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PaymentIntentAmountDetailsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PaymentIntentAmountDetails &&
            (identical(other.tip, tip) || other.tip == tip));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, tip);

  @override
  String toString() {
    return 'PaymentIntentAmountDetails(tip: $tip)';
  }
}

/// @nodoc
abstract mixin class _$PaymentIntentAmountDetailsCopyWith<$Res>
    implements $PaymentIntentAmountDetailsCopyWith<$Res> {
  factory _$PaymentIntentAmountDetailsCopyWith(
          _PaymentIntentAmountDetails value,
          $Res Function(_PaymentIntentAmountDetails) _then) =
      __$PaymentIntentAmountDetailsCopyWithImpl;
  @override
  @useResult
  $Res call({PaymentIntentTip? tip});

  @override
  $PaymentIntentTipCopyWith<$Res>? get tip;
}

/// @nodoc
class __$PaymentIntentAmountDetailsCopyWithImpl<$Res>
    implements _$PaymentIntentAmountDetailsCopyWith<$Res> {
  __$PaymentIntentAmountDetailsCopyWithImpl(this._self, this._then);

  final _PaymentIntentAmountDetails _self;
  final $Res Function(_PaymentIntentAmountDetails) _then;

  /// Create a copy of PaymentIntentAmountDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? tip = freezed,
  }) {
    return _then(_PaymentIntentAmountDetails(
      tip: freezed == tip
          ? _self.tip
          : tip // ignore: cast_nullable_to_non_nullable
              as PaymentIntentTip?,
    ));
  }

  /// Create a copy of PaymentIntentAmountDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PaymentIntentTipCopyWith<$Res>? get tip {
    if (_self.tip == null) {
      return null;
    }

    return $PaymentIntentTipCopyWith<$Res>(_self.tip!, (value) {
      return _then(_self.copyWith(tip: value));
    });
  }
}

/// @nodoc
mixin _$PaymentIntentTip {
  /// Portion of the amount that corresponds to a tip.
  int? get amount;

  /// Create a copy of PaymentIntentTip
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PaymentIntentTipCopyWith<PaymentIntentTip> get copyWith =>
      _$PaymentIntentTipCopyWithImpl<PaymentIntentTip>(
          this as PaymentIntentTip, _$identity);

  /// Serializes this PaymentIntentTip to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PaymentIntentTip &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, amount);

  @override
  String toString() {
    return 'PaymentIntentTip(amount: $amount)';
  }
}

/// @nodoc
abstract mixin class $PaymentIntentTipCopyWith<$Res> {
  factory $PaymentIntentTipCopyWith(
          PaymentIntentTip value, $Res Function(PaymentIntentTip) _then) =
      _$PaymentIntentTipCopyWithImpl;
  @useResult
  $Res call({int? amount});
}

/// @nodoc
class _$PaymentIntentTipCopyWithImpl<$Res>
    implements $PaymentIntentTipCopyWith<$Res> {
  _$PaymentIntentTipCopyWithImpl(this._self, this._then);

  final PaymentIntentTip _self;
  final $Res Function(PaymentIntentTip) _then;

  /// Create a copy of PaymentIntentTip
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = freezed,
  }) {
    return _then(_self.copyWith(
      amount: freezed == amount
          ? _self.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _PaymentIntentTip implements PaymentIntentTip {
  const _PaymentIntentTip({this.amount});
  factory _PaymentIntentTip.fromJson(Map<String, dynamic> json) =>
      _$PaymentIntentTipFromJson(json);

  /// Portion of the amount that corresponds to a tip.
  @override
  final int? amount;

  /// Create a copy of PaymentIntentTip
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PaymentIntentTipCopyWith<_PaymentIntentTip> get copyWith =>
      __$PaymentIntentTipCopyWithImpl<_PaymentIntentTip>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PaymentIntentTipToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PaymentIntentTip &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, amount);

  @override
  String toString() {
    return 'PaymentIntentTip(amount: $amount)';
  }
}

/// @nodoc
abstract mixin class _$PaymentIntentTipCopyWith<$Res>
    implements $PaymentIntentTipCopyWith<$Res> {
  factory _$PaymentIntentTipCopyWith(
          _PaymentIntentTip value, $Res Function(_PaymentIntentTip) _then) =
      __$PaymentIntentTipCopyWithImpl;
  @override
  @useResult
  $Res call({int? amount});
}

/// @nodoc
class __$PaymentIntentTipCopyWithImpl<$Res>
    implements _$PaymentIntentTipCopyWith<$Res> {
  __$PaymentIntentTipCopyWithImpl(this._self, this._then);

  final _PaymentIntentTip _self;
  final $Res Function(_PaymentIntentTip) _then;

  /// Create a copy of PaymentIntentTip
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? amount = freezed,
  }) {
    return _then(_PaymentIntentTip(
      amount: freezed == amount
          ? _self.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PaymentIntentAutomaticPaymentMethods {
  /// Automatically calculates compatible payment methods
  bool? get enabled;

  /// Create a copy of PaymentIntentAutomaticPaymentMethods
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PaymentIntentAutomaticPaymentMethodsCopyWith<
          PaymentIntentAutomaticPaymentMethods>
      get copyWith => _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<
              PaymentIntentAutomaticPaymentMethods>(
          this as PaymentIntentAutomaticPaymentMethods, _$identity);

  /// Serializes this PaymentIntentAutomaticPaymentMethods to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PaymentIntentAutomaticPaymentMethods &&
            (identical(other.enabled, enabled) || other.enabled == enabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, enabled);

  @override
  String toString() {
    return 'PaymentIntentAutomaticPaymentMethods(enabled: $enabled)';
  }
}

/// @nodoc
abstract mixin class $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  factory $PaymentIntentAutomaticPaymentMethodsCopyWith(
          PaymentIntentAutomaticPaymentMethods value,
          $Res Function(PaymentIntentAutomaticPaymentMethods) _then) =
      _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl;
  @useResult
  $Res call({bool? enabled});
}

/// @nodoc
class _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<$Res>
    implements $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl(this._self, this._then);

  final PaymentIntentAutomaticPaymentMethods _self;
  final $Res Function(PaymentIntentAutomaticPaymentMethods) _then;

  /// Create a copy of PaymentIntentAutomaticPaymentMethods
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = freezed,
  }) {
    return _then(_self.copyWith(
      enabled: freezed == enabled
          ? _self.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _PaymentIntentAutomaticPaymentMethods
    implements PaymentIntentAutomaticPaymentMethods {
  const _PaymentIntentAutomaticPaymentMethods({required this.enabled});
  factory _PaymentIntentAutomaticPaymentMethods.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentIntentAutomaticPaymentMethodsFromJson(json);

  /// Automatically calculates compatible payment methods
  @override
  final bool? enabled;

  /// Create a copy of PaymentIntentAutomaticPaymentMethods
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PaymentIntentAutomaticPaymentMethodsCopyWith<
          _PaymentIntentAutomaticPaymentMethods>
      get copyWith => __$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<
          _PaymentIntentAutomaticPaymentMethods>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PaymentIntentAutomaticPaymentMethodsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PaymentIntentAutomaticPaymentMethods &&
            (identical(other.enabled, enabled) || other.enabled == enabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, enabled);

  @override
  String toString() {
    return 'PaymentIntentAutomaticPaymentMethods(enabled: $enabled)';
  }
}

/// @nodoc
abstract mixin class _$PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>
    implements $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  factory _$PaymentIntentAutomaticPaymentMethodsCopyWith(
          _PaymentIntentAutomaticPaymentMethods value,
          $Res Function(_PaymentIntentAutomaticPaymentMethods) _then) =
      __$PaymentIntentAutomaticPaymentMethodsCopyWithImpl;
  @override
  @useResult
  $Res call({bool? enabled});
}

/// @nodoc
class __$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<$Res>
    implements _$PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  __$PaymentIntentAutomaticPaymentMethodsCopyWithImpl(this._self, this._then);

  final _PaymentIntentAutomaticPaymentMethods _self;
  final $Res Function(_PaymentIntentAutomaticPaymentMethods) _then;

  /// Create a copy of PaymentIntentAutomaticPaymentMethods
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? enabled = freezed,
  }) {
    return _then(_PaymentIntentAutomaticPaymentMethods(
      enabled: freezed == enabled
          ? _self.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

// dart format on
