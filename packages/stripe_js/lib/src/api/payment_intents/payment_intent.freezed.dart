// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'payment_intent.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

PaymentIntent _$PaymentIntentFromJson(Map<String, dynamic> json) {
  return _PaymentIntent.fromJson(json);
}

/// @nodoc
mixin _$PaymentIntent {
  /// Unique identifier for the object.
  String get id => throw _privateConstructorUsedError;

  /// String representing the object’s type.
  /// Objects of the same type share the same value.
  /// Value is "payment_intent".
  String get object => throw _privateConstructorUsedError;

  /// Amount intended to be collected by this PaymentIntent.
  /// A positive integer representing how much to charge in the
  /// smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to
  /// charge ¥100, a zero-decimal currency).
  /// The minimum amount is $0.50 US or equivalent in charge currency.
  /// The amount value supports up to eight digits
  /// (e.g., a value of 99999999 for a USD charge of $999,999.99).
  int get amount => throw _privateConstructorUsedError;

  /// The amount that can be captured with from this PaymentIntent (in cents).
  @JsonKey(name: "amount_capturable")
  int? get amountCapturable => throw _privateConstructorUsedError;

  /// Details about items included in the amount
  @JsonKey(name: "amount_details")
  PaymentIntentAmountDetails? get amountDetails =>
      throw _privateConstructorUsedError;

  /// The amount that was collected from this PaymentIntent (in cents).
  @JsonKey(name: "amount_received")
  int? get amountReceived => throw _privateConstructorUsedError;

  /// CONNECT ONLY
  /// ID of the Connect application that created the PaymentIntent.
  String? get application => throw _privateConstructorUsedError;

  /// CONNECT ONLY
  /// The amount of the application fee (if any) that will be requested to
  /// be applied to the payment and transferred to the application owner’s
  /// Stripe account. The amount of the application fee collected will be
  /// capped at the total payment amount.
  /// For more information, see the PaymentIntents use
  /// case for connected accounts..
  @JsonKey(name: "application_fee_amount")
  int? get applicationFeeAmount => throw _privateConstructorUsedError;

  /// Settings to configure compatible payment methods from the
  /// Stripe Dashboard
  @JsonKey(name: "automatic_payment_methods")
  PaymentIntentAutomaticPaymentMethods? get automaticPaymentMethods =>
      throw _privateConstructorUsedError;

  /// Populated when status is canceled, this is the time at which the
  /// PaymentIntent was canceled. Measured in seconds since the Unix epoch.
  @JsonKey(name: "canceled_at")
  int? get canceledAt => throw _privateConstructorUsedError;

  /// Reason for cancellation of this PaymentIntent,
  /// either user-provided
  /// (duplicate, fraudulent, requested_by_customer, or abandoned) or
  /// generated by Stripe internally
  /// (failed_invoice, void_invoice, or automatic).
  @JsonKey(name: "cancellation_reason")
  PaymentIntentCancellationReason? get cancellationReason =>
      throw _privateConstructorUsedError;

  /// The client secret of this PaymentIntent. Used for client-side retrieval
  /// using a publishable key.
  /// The client secret can be used to complete a payment from your frontend.
  /// It should not be stored, logged, or exposed to anyone other than the
  /// customer. Make sure that you have TLS enabled on any page that includes
  /// the client secret.
  ///
  /// Refer to our docs to accept a payment and learn about how `client_secret`
  /// should be handled.
  @JsonKey(name: "client_secret")
  String get clientSecret => throw _privateConstructorUsedError;

  /// Controls when the funds will be captured from the customer’s account.
  @JsonKey(name: "capture_method")
  PaymentIntentCaptureMethod get captureMethod =>
      throw _privateConstructorUsedError;
  @JsonKey(name: "confirmation_method")
  PaymentIntentConfirmationMethod get confirmationMethod =>
      throw _privateConstructorUsedError;

  /// Time at which the object was created. Measured in seconds since the
  /// Unix epoch.
  int? get created => throw _privateConstructorUsedError;

  /// Three-letter ISO currency code, in lowercase. Must be a supported
  /// currency.
  String get currency => throw _privateConstructorUsedError;

  /// ID of the Customer this PaymentIntent belongs to, if one exists.
  /// Payment methods attached to other Customers cannot be used with this
  /// PaymentIntent.
  ///
  /// If present in combination with setup_future_usage,
  /// this PaymentIntent’s payment method will be attached to the
  /// Customer after the PaymentIntent has been confirmed and any
  /// required actions from the user are complete.
  String? get customer => throw _privateConstructorUsedError;

  /// An arbitrary string attached to the object.
  /// Often useful for displaying to users.
  String? get description => throw _privateConstructorUsedError;

  /// ID of the invoice that created this PaymentIntent, if it exists.
  String? get invoice => throw _privateConstructorUsedError;

  /// The payment error encountered in the previous PaymentIntent confirmation.
  /// It will be cleared if the PaymentIntent is later updated for any reason.
  @JsonKey(name: "last_payment_error")
  StripeError? get lastPaymentError => throw _privateConstructorUsedError;

  /// The latest charge created by this payment intent.
  @JsonKey(name: "latest_charge")
  String? get latestCharge => throw _privateConstructorUsedError;

  /// Has the value true if the object exists in live mode or the
  /// value false if the object exists in test mode.
  bool get livemode => throw _privateConstructorUsedError;

  /// Set of key-value pairs that you can attach to an object.
  /// This can be useful for storing additional information about the
  /// object in a structured format.
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  /// If present, this property tells you what actions you need to
  /// take in order for your customer to fulfill a payment using the
  /// provided source.
  @JsonKey(name: "next_action")
  dynamic get nextAction => throw _privateConstructorUsedError;

  /// CONNECT ONLY
  /// The account (if any) for which the funds of the PaymentIntent are
  /// intended. See the PaymentIntents use case for connected accounts
  /// for details.
  @JsonKey(name: "on_behalf_of")
  String? get onBehalfOf => throw _privateConstructorUsedError;

  /// ID of the payment method used in this PaymentIntent.
  @JsonKey(name: "payment_method")
  String? get paymentMethod => throw _privateConstructorUsedError;

  /// Payment-method-specific configuration for this PaymentIntent.
  @JsonKey(name: "payment_method_options")
  Map<dynamic, dynamic> get paymentMethodOptions =>
      throw _privateConstructorUsedError;

  /// The list of payment method types (e.g. card) that this PaymentIntent
  /// is allowed to use.
  @JsonKey(name: "payment_method_types")
  List<PaymentMethodType> get paymentMethodTypes =>
      throw _privateConstructorUsedError;

  /// If present, this property tells you about the processing state of the payment.
  dynamic get processing => throw _privateConstructorUsedError;

  /// Email address that the receipt for the resulting payment will be sent to.
  /// If receipt_email is specified for a payment in live mode, a receipt
  /// will be sent regardless of your email settings.
  @JsonKey(name: "receipt_email")
  String? get receiptEmail =>
      throw _privateConstructorUsedError; // ID of the review associated with this PaymentIntent, if any.
  String? get review => throw _privateConstructorUsedError;

  /// Indicates that you intend to make future payments with this
  /// PaymentIntent’s payment method.
  /// Providing this parameter will attach the payment method to the
  /// PaymentIntent’s Customer, if present, after the PaymentIntent is
  /// confirmed and any required actions from the user are complete. I
  /// If no Customer was provided, the payment method can still be attached to
  /// a Customer after the transaction completes.
  /// When processing card payments, Stripe also uses setup_future_usage
  /// to dynamically optimize your payment flow and comply with regional
  /// legislation and network rules, such as SCA.
  @JsonKey(name: "setup_future_usage")
  PaymentIntentSetupFutureUsage? get setupFutureUsage =>
      throw _privateConstructorUsedError;

  /// Shipping information for this PaymentIntent.
  ShippingDetails? get shipping => throw _privateConstructorUsedError;

  /// For non-card charges, you can use this value as the complete
  /// description that appears on your customers’ statements.
  /// Must contain at least one letter, maximum 22 characters.
  @JsonKey(name: "statement_descriptor")
  String? get statementDescriptor => throw _privateConstructorUsedError;

  /// Provides information about a card payment that customers see on
  /// their statements.
  /// Concatenated with the prefix (shortened descriptor) or statement
  /// descriptor that’s set on the account to form the complete statement
  /// descriptor. Maximum 22 characters for the concatenated descriptor.
  @JsonKey(name: "statement_descriptor_suffix")
  String? get statementDescriptorSuffix => throw _privateConstructorUsedError;

  /// Status of this PaymentIntent, one of requires_payment_method,
  /// requires_confirmation, requires_action, processing, requires_capture,
  /// canceled, or succeeded.
  PaymentIntentsStatus get status => throw _privateConstructorUsedError;

  /// CONNECT ONLY
  /// The data with which to automatically create a Transfer when the payment
  /// is finalized. See the PaymentIntents use case for connected
  /// accounts for details.
  @JsonKey(name: "transfer_data")
  dynamic get transferData => throw _privateConstructorUsedError;

  /// CONNECT ONLY
  /// A string that identifies the resulting payment as part of a group.
  /// See the PaymentIntents use case for connected accounts for details.
  @JsonKey(name: "transfer_group")
  dynamic get transferGroup => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PaymentIntentCopyWith<PaymentIntent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentIntentCopyWith<$Res> {
  factory $PaymentIntentCopyWith(
          PaymentIntent value, $Res Function(PaymentIntent) then) =
      _$PaymentIntentCopyWithImpl<$Res, PaymentIntent>;
  @useResult
  $Res call(
      {String id,
      String object,
      int amount,
      @JsonKey(name: "amount_capturable") int? amountCapturable,
      @JsonKey(name: "amount_details")
      PaymentIntentAmountDetails? amountDetails,
      @JsonKey(name: "amount_received") int? amountReceived,
      String? application,
      @JsonKey(name: "application_fee_amount") int? applicationFeeAmount,
      @JsonKey(name: "automatic_payment_methods")
      PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods,
      @JsonKey(name: "canceled_at") int? canceledAt,
      @JsonKey(name: "cancellation_reason")
      PaymentIntentCancellationReason? cancellationReason,
      @JsonKey(name: "client_secret") String clientSecret,
      @JsonKey(name: "capture_method") PaymentIntentCaptureMethod captureMethod,
      @JsonKey(name: "confirmation_method")
      PaymentIntentConfirmationMethod confirmationMethod,
      int? created,
      String currency,
      String? customer,
      String? description,
      String? invoice,
      @JsonKey(name: "last_payment_error") StripeError? lastPaymentError,
      @JsonKey(name: "latest_charge") String? latestCharge,
      bool livemode,
      Map<String, dynamic> metadata,
      @JsonKey(name: "next_action") dynamic nextAction,
      @JsonKey(name: "on_behalf_of") String? onBehalfOf,
      @JsonKey(name: "payment_method") String? paymentMethod,
      @JsonKey(name: "payment_method_options")
      Map<dynamic, dynamic> paymentMethodOptions,
      @JsonKey(name: "payment_method_types")
      List<PaymentMethodType> paymentMethodTypes,
      dynamic processing,
      @JsonKey(name: "receipt_email") String? receiptEmail,
      String? review,
      @JsonKey(name: "setup_future_usage")
      PaymentIntentSetupFutureUsage? setupFutureUsage,
      ShippingDetails? shipping,
      @JsonKey(name: "statement_descriptor") String? statementDescriptor,
      @JsonKey(name: "statement_descriptor_suffix")
      String? statementDescriptorSuffix,
      PaymentIntentsStatus status,
      @JsonKey(name: "transfer_data") dynamic transferData,
      @JsonKey(name: "transfer_group") dynamic transferGroup});

  $PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails;
  $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>?
      get automaticPaymentMethods;
  $StripeErrorCopyWith<$Res>? get lastPaymentError;
  $ShippingDetailsCopyWith<$Res>? get shipping;
}

/// @nodoc
class _$PaymentIntentCopyWithImpl<$Res, $Val extends PaymentIntent>
    implements $PaymentIntentCopyWith<$Res> {
  _$PaymentIntentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? amount = null,
    Object? amountCapturable = freezed,
    Object? amountDetails = freezed,
    Object? amountReceived = freezed,
    Object? application = freezed,
    Object? applicationFeeAmount = freezed,
    Object? automaticPaymentMethods = freezed,
    Object? canceledAt = freezed,
    Object? cancellationReason = freezed,
    Object? clientSecret = null,
    Object? captureMethod = null,
    Object? confirmationMethod = null,
    Object? created = freezed,
    Object? currency = null,
    Object? customer = freezed,
    Object? description = freezed,
    Object? invoice = freezed,
    Object? lastPaymentError = freezed,
    Object? latestCharge = freezed,
    Object? livemode = null,
    Object? metadata = null,
    Object? nextAction = freezed,
    Object? onBehalfOf = freezed,
    Object? paymentMethod = freezed,
    Object? paymentMethodOptions = null,
    Object? paymentMethodTypes = null,
    Object? processing = freezed,
    Object? receiptEmail = freezed,
    Object? review = freezed,
    Object? setupFutureUsage = freezed,
    Object? shipping = freezed,
    Object? statementDescriptor = freezed,
    Object? statementDescriptorSuffix = freezed,
    Object? status = null,
    Object? transferData = freezed,
    Object? transferGroup = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int,
      amountCapturable: freezed == amountCapturable
          ? _value.amountCapturable
          : amountCapturable // ignore: cast_nullable_to_non_nullable
              as int?,
      amountDetails: freezed == amountDetails
          ? _value.amountDetails
          : amountDetails // ignore: cast_nullable_to_non_nullable
              as PaymentIntentAmountDetails?,
      amountReceived: freezed == amountReceived
          ? _value.amountReceived
          : amountReceived // ignore: cast_nullable_to_non_nullable
              as int?,
      application: freezed == application
          ? _value.application
          : application // ignore: cast_nullable_to_non_nullable
              as String?,
      applicationFeeAmount: freezed == applicationFeeAmount
          ? _value.applicationFeeAmount
          : applicationFeeAmount // ignore: cast_nullable_to_non_nullable
              as int?,
      automaticPaymentMethods: freezed == automaticPaymentMethods
          ? _value.automaticPaymentMethods
          : automaticPaymentMethods // ignore: cast_nullable_to_non_nullable
              as PaymentIntentAutomaticPaymentMethods?,
      canceledAt: freezed == canceledAt
          ? _value.canceledAt
          : canceledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancellationReason: freezed == cancellationReason
          ? _value.cancellationReason
          : cancellationReason // ignore: cast_nullable_to_non_nullable
              as PaymentIntentCancellationReason?,
      clientSecret: null == clientSecret
          ? _value.clientSecret
          : clientSecret // ignore: cast_nullable_to_non_nullable
              as String,
      captureMethod: null == captureMethod
          ? _value.captureMethod
          : captureMethod // ignore: cast_nullable_to_non_nullable
              as PaymentIntentCaptureMethod,
      confirmationMethod: null == confirmationMethod
          ? _value.confirmationMethod
          : confirmationMethod // ignore: cast_nullable_to_non_nullable
              as PaymentIntentConfirmationMethod,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      currency: null == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String,
      customer: freezed == customer
          ? _value.customer
          : customer // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      invoice: freezed == invoice
          ? _value.invoice
          : invoice // ignore: cast_nullable_to_non_nullable
              as String?,
      lastPaymentError: freezed == lastPaymentError
          ? _value.lastPaymentError
          : lastPaymentError // ignore: cast_nullable_to_non_nullable
              as StripeError?,
      latestCharge: freezed == latestCharge
          ? _value.latestCharge
          : latestCharge // ignore: cast_nullable_to_non_nullable
              as String?,
      livemode: null == livemode
          ? _value.livemode
          : livemode // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      nextAction: freezed == nextAction
          ? _value.nextAction
          : nextAction // ignore: cast_nullable_to_non_nullable
              as dynamic,
      onBehalfOf: freezed == onBehalfOf
          ? _value.onBehalfOf
          : onBehalfOf // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentMethod: freezed == paymentMethod
          ? _value.paymentMethod
          : paymentMethod // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentMethodOptions: null == paymentMethodOptions
          ? _value.paymentMethodOptions
          : paymentMethodOptions // ignore: cast_nullable_to_non_nullable
              as Map<dynamic, dynamic>,
      paymentMethodTypes: null == paymentMethodTypes
          ? _value.paymentMethodTypes
          : paymentMethodTypes // ignore: cast_nullable_to_non_nullable
              as List<PaymentMethodType>,
      processing: freezed == processing
          ? _value.processing
          : processing // ignore: cast_nullable_to_non_nullable
              as dynamic,
      receiptEmail: freezed == receiptEmail
          ? _value.receiptEmail
          : receiptEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      review: freezed == review
          ? _value.review
          : review // ignore: cast_nullable_to_non_nullable
              as String?,
      setupFutureUsage: freezed == setupFutureUsage
          ? _value.setupFutureUsage
          : setupFutureUsage // ignore: cast_nullable_to_non_nullable
              as PaymentIntentSetupFutureUsage?,
      shipping: freezed == shipping
          ? _value.shipping
          : shipping // ignore: cast_nullable_to_non_nullable
              as ShippingDetails?,
      statementDescriptor: freezed == statementDescriptor
          ? _value.statementDescriptor
          : statementDescriptor // ignore: cast_nullable_to_non_nullable
              as String?,
      statementDescriptorSuffix: freezed == statementDescriptorSuffix
          ? _value.statementDescriptorSuffix
          : statementDescriptorSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as PaymentIntentsStatus,
      transferData: freezed == transferData
          ? _value.transferData
          : transferData // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transferGroup: freezed == transferGroup
          ? _value.transferGroup
          : transferGroup // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails {
    if (_value.amountDetails == null) {
      return null;
    }

    return $PaymentIntentAmountDetailsCopyWith<$Res>(_value.amountDetails!,
        (value) {
      return _then(_value.copyWith(amountDetails: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>?
      get automaticPaymentMethods {
    if (_value.automaticPaymentMethods == null) {
      return null;
    }

    return $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>(
        _value.automaticPaymentMethods!, (value) {
      return _then(_value.copyWith(automaticPaymentMethods: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $StripeErrorCopyWith<$Res>? get lastPaymentError {
    if (_value.lastPaymentError == null) {
      return null;
    }

    return $StripeErrorCopyWith<$Res>(_value.lastPaymentError!, (value) {
      return _then(_value.copyWith(lastPaymentError: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ShippingDetailsCopyWith<$Res>? get shipping {
    if (_value.shipping == null) {
      return null;
    }

    return $ShippingDetailsCopyWith<$Res>(_value.shipping!, (value) {
      return _then(_value.copyWith(shipping: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PaymentIntentCopyWith<$Res>
    implements $PaymentIntentCopyWith<$Res> {
  factory _$$_PaymentIntentCopyWith(
          _$_PaymentIntent value, $Res Function(_$_PaymentIntent) then) =
      __$$_PaymentIntentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String object,
      int amount,
      @JsonKey(name: "amount_capturable") int? amountCapturable,
      @JsonKey(name: "amount_details")
      PaymentIntentAmountDetails? amountDetails,
      @JsonKey(name: "amount_received") int? amountReceived,
      String? application,
      @JsonKey(name: "application_fee_amount") int? applicationFeeAmount,
      @JsonKey(name: "automatic_payment_methods")
      PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods,
      @JsonKey(name: "canceled_at") int? canceledAt,
      @JsonKey(name: "cancellation_reason")
      PaymentIntentCancellationReason? cancellationReason,
      @JsonKey(name: "client_secret") String clientSecret,
      @JsonKey(name: "capture_method") PaymentIntentCaptureMethod captureMethod,
      @JsonKey(name: "confirmation_method")
      PaymentIntentConfirmationMethod confirmationMethod,
      int? created,
      String currency,
      String? customer,
      String? description,
      String? invoice,
      @JsonKey(name: "last_payment_error") StripeError? lastPaymentError,
      @JsonKey(name: "latest_charge") String? latestCharge,
      bool livemode,
      Map<String, dynamic> metadata,
      @JsonKey(name: "next_action") dynamic nextAction,
      @JsonKey(name: "on_behalf_of") String? onBehalfOf,
      @JsonKey(name: "payment_method") String? paymentMethod,
      @JsonKey(name: "payment_method_options")
      Map<dynamic, dynamic> paymentMethodOptions,
      @JsonKey(name: "payment_method_types")
      List<PaymentMethodType> paymentMethodTypes,
      dynamic processing,
      @JsonKey(name: "receipt_email") String? receiptEmail,
      String? review,
      @JsonKey(name: "setup_future_usage")
      PaymentIntentSetupFutureUsage? setupFutureUsage,
      ShippingDetails? shipping,
      @JsonKey(name: "statement_descriptor") String? statementDescriptor,
      @JsonKey(name: "statement_descriptor_suffix")
      String? statementDescriptorSuffix,
      PaymentIntentsStatus status,
      @JsonKey(name: "transfer_data") dynamic transferData,
      @JsonKey(name: "transfer_group") dynamic transferGroup});

  @override
  $PaymentIntentAmountDetailsCopyWith<$Res>? get amountDetails;
  @override
  $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>?
      get automaticPaymentMethods;
  @override
  $StripeErrorCopyWith<$Res>? get lastPaymentError;
  @override
  $ShippingDetailsCopyWith<$Res>? get shipping;
}

/// @nodoc
class __$$_PaymentIntentCopyWithImpl<$Res>
    extends _$PaymentIntentCopyWithImpl<$Res, _$_PaymentIntent>
    implements _$$_PaymentIntentCopyWith<$Res> {
  __$$_PaymentIntentCopyWithImpl(
      _$_PaymentIntent _value, $Res Function(_$_PaymentIntent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? amount = null,
    Object? amountCapturable = freezed,
    Object? amountDetails = freezed,
    Object? amountReceived = freezed,
    Object? application = freezed,
    Object? applicationFeeAmount = freezed,
    Object? automaticPaymentMethods = freezed,
    Object? canceledAt = freezed,
    Object? cancellationReason = freezed,
    Object? clientSecret = null,
    Object? captureMethod = null,
    Object? confirmationMethod = null,
    Object? created = freezed,
    Object? currency = null,
    Object? customer = freezed,
    Object? description = freezed,
    Object? invoice = freezed,
    Object? lastPaymentError = freezed,
    Object? latestCharge = freezed,
    Object? livemode = null,
    Object? metadata = null,
    Object? nextAction = freezed,
    Object? onBehalfOf = freezed,
    Object? paymentMethod = freezed,
    Object? paymentMethodOptions = null,
    Object? paymentMethodTypes = null,
    Object? processing = freezed,
    Object? receiptEmail = freezed,
    Object? review = freezed,
    Object? setupFutureUsage = freezed,
    Object? shipping = freezed,
    Object? statementDescriptor = freezed,
    Object? statementDescriptorSuffix = freezed,
    Object? status = null,
    Object? transferData = freezed,
    Object? transferGroup = freezed,
  }) {
    return _then(_$_PaymentIntent(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int,
      amountCapturable: freezed == amountCapturable
          ? _value.amountCapturable
          : amountCapturable // ignore: cast_nullable_to_non_nullable
              as int?,
      amountDetails: freezed == amountDetails
          ? _value.amountDetails
          : amountDetails // ignore: cast_nullable_to_non_nullable
              as PaymentIntentAmountDetails?,
      amountReceived: freezed == amountReceived
          ? _value.amountReceived
          : amountReceived // ignore: cast_nullable_to_non_nullable
              as int?,
      application: freezed == application
          ? _value.application
          : application // ignore: cast_nullable_to_non_nullable
              as String?,
      applicationFeeAmount: freezed == applicationFeeAmount
          ? _value.applicationFeeAmount
          : applicationFeeAmount // ignore: cast_nullable_to_non_nullable
              as int?,
      automaticPaymentMethods: freezed == automaticPaymentMethods
          ? _value.automaticPaymentMethods
          : automaticPaymentMethods // ignore: cast_nullable_to_non_nullable
              as PaymentIntentAutomaticPaymentMethods?,
      canceledAt: freezed == canceledAt
          ? _value.canceledAt
          : canceledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancellationReason: freezed == cancellationReason
          ? _value.cancellationReason
          : cancellationReason // ignore: cast_nullable_to_non_nullable
              as PaymentIntentCancellationReason?,
      clientSecret: null == clientSecret
          ? _value.clientSecret
          : clientSecret // ignore: cast_nullable_to_non_nullable
              as String,
      captureMethod: null == captureMethod
          ? _value.captureMethod
          : captureMethod // ignore: cast_nullable_to_non_nullable
              as PaymentIntentCaptureMethod,
      confirmationMethod: null == confirmationMethod
          ? _value.confirmationMethod
          : confirmationMethod // ignore: cast_nullable_to_non_nullable
              as PaymentIntentConfirmationMethod,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      currency: null == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String,
      customer: freezed == customer
          ? _value.customer
          : customer // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      invoice: freezed == invoice
          ? _value.invoice
          : invoice // ignore: cast_nullable_to_non_nullable
              as String?,
      lastPaymentError: freezed == lastPaymentError
          ? _value.lastPaymentError
          : lastPaymentError // ignore: cast_nullable_to_non_nullable
              as StripeError?,
      latestCharge: freezed == latestCharge
          ? _value.latestCharge
          : latestCharge // ignore: cast_nullable_to_non_nullable
              as String?,
      livemode: null == livemode
          ? _value.livemode
          : livemode // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      nextAction: freezed == nextAction
          ? _value.nextAction
          : nextAction // ignore: cast_nullable_to_non_nullable
              as dynamic,
      onBehalfOf: freezed == onBehalfOf
          ? _value.onBehalfOf
          : onBehalfOf // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentMethod: freezed == paymentMethod
          ? _value.paymentMethod
          : paymentMethod // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentMethodOptions: null == paymentMethodOptions
          ? _value._paymentMethodOptions
          : paymentMethodOptions // ignore: cast_nullable_to_non_nullable
              as Map<dynamic, dynamic>,
      paymentMethodTypes: null == paymentMethodTypes
          ? _value._paymentMethodTypes
          : paymentMethodTypes // ignore: cast_nullable_to_non_nullable
              as List<PaymentMethodType>,
      processing: freezed == processing
          ? _value.processing
          : processing // ignore: cast_nullable_to_non_nullable
              as dynamic,
      receiptEmail: freezed == receiptEmail
          ? _value.receiptEmail
          : receiptEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      review: freezed == review
          ? _value.review
          : review // ignore: cast_nullable_to_non_nullable
              as String?,
      setupFutureUsage: freezed == setupFutureUsage
          ? _value.setupFutureUsage
          : setupFutureUsage // ignore: cast_nullable_to_non_nullable
              as PaymentIntentSetupFutureUsage?,
      shipping: freezed == shipping
          ? _value.shipping
          : shipping // ignore: cast_nullable_to_non_nullable
              as ShippingDetails?,
      statementDescriptor: freezed == statementDescriptor
          ? _value.statementDescriptor
          : statementDescriptor // ignore: cast_nullable_to_non_nullable
              as String?,
      statementDescriptorSuffix: freezed == statementDescriptorSuffix
          ? _value.statementDescriptorSuffix
          : statementDescriptorSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as PaymentIntentsStatus,
      transferData: freezed == transferData
          ? _value.transferData
          : transferData // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transferGroup: freezed == transferGroup
          ? _value.transferGroup
          : transferGroup // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PaymentIntent implements _PaymentIntent {
  const _$_PaymentIntent(
      {required this.id,
      this.object = "payment_intent",
      required this.amount,
      @JsonKey(name: "amount_capturable") this.amountCapturable,
      @JsonKey(name: "amount_details")
      this.amountDetails = const PaymentIntentAmountDetails(),
      @JsonKey(name: "amount_received") this.amountReceived,
      this.application,
      @JsonKey(name: "application_fee_amount") this.applicationFeeAmount,
      @JsonKey(name: "automatic_payment_methods") this.automaticPaymentMethods,
      @JsonKey(name: "canceled_at") this.canceledAt,
      @JsonKey(name: "cancellation_reason") this.cancellationReason,
      @JsonKey(name: "client_secret") required this.clientSecret,
      @JsonKey(name: "capture_method")
      this.captureMethod = PaymentIntentCaptureMethod.automatic,
      @JsonKey(name: "confirmation_method")
      this.confirmationMethod = PaymentIntentConfirmationMethod.automatic,
      this.created,
      required this.currency,
      this.customer,
      this.description,
      this.invoice,
      @JsonKey(name: "last_payment_error") this.lastPaymentError,
      @JsonKey(name: "latest_charge") this.latestCharge,
      required this.livemode,
      final Map<String, dynamic> metadata = const {},
      @JsonKey(name: "next_action") this.nextAction,
      @JsonKey(name: "on_behalf_of") this.onBehalfOf,
      @JsonKey(name: "payment_method") this.paymentMethod,
      @JsonKey(name: "payment_method_options")
      final Map<dynamic, dynamic> paymentMethodOptions = const {},
      @JsonKey(name: "payment_method_types")
      final List<PaymentMethodType> paymentMethodTypes = const [],
      this.processing,
      @JsonKey(name: "receipt_email") this.receiptEmail,
      this.review,
      @JsonKey(name: "setup_future_usage") this.setupFutureUsage,
      this.shipping,
      @JsonKey(name: "statement_descriptor") this.statementDescriptor,
      @JsonKey(name: "statement_descriptor_suffix")
      this.statementDescriptorSuffix,
      required this.status,
      @JsonKey(name: "transfer_data") this.transferData,
      @JsonKey(name: "transfer_group") this.transferGroup})
      : _metadata = metadata,
        _paymentMethodOptions = paymentMethodOptions,
        _paymentMethodTypes = paymentMethodTypes;

  factory _$_PaymentIntent.fromJson(Map<String, dynamic> json) =>
      _$$_PaymentIntentFromJson(json);

  /// Unique identifier for the object.
  @override
  final String id;

  /// String representing the object’s type.
  /// Objects of the same type share the same value.
  /// Value is "payment_intent".
  @override
  @JsonKey()
  final String object;

  /// Amount intended to be collected by this PaymentIntent.
  /// A positive integer representing how much to charge in the
  /// smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to
  /// charge ¥100, a zero-decimal currency).
  /// The minimum amount is $0.50 US or equivalent in charge currency.
  /// The amount value supports up to eight digits
  /// (e.g., a value of 99999999 for a USD charge of $999,999.99).
  @override
  final int amount;

  /// The amount that can be captured with from this PaymentIntent (in cents).
  @override
  @JsonKey(name: "amount_capturable")
  final int? amountCapturable;

  /// Details about items included in the amount
  @override
  @JsonKey(name: "amount_details")
  final PaymentIntentAmountDetails? amountDetails;

  /// The amount that was collected from this PaymentIntent (in cents).
  @override
  @JsonKey(name: "amount_received")
  final int? amountReceived;

  /// CONNECT ONLY
  /// ID of the Connect application that created the PaymentIntent.
  @override
  final String? application;

  /// CONNECT ONLY
  /// The amount of the application fee (if any) that will be requested to
  /// be applied to the payment and transferred to the application owner’s
  /// Stripe account. The amount of the application fee collected will be
  /// capped at the total payment amount.
  /// For more information, see the PaymentIntents use
  /// case for connected accounts..
  @override
  @JsonKey(name: "application_fee_amount")
  final int? applicationFeeAmount;

  /// Settings to configure compatible payment methods from the
  /// Stripe Dashboard
  @override
  @JsonKey(name: "automatic_payment_methods")
  final PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods;

  /// Populated when status is canceled, this is the time at which the
  /// PaymentIntent was canceled. Measured in seconds since the Unix epoch.
  @override
  @JsonKey(name: "canceled_at")
  final int? canceledAt;

  /// Reason for cancellation of this PaymentIntent,
  /// either user-provided
  /// (duplicate, fraudulent, requested_by_customer, or abandoned) or
  /// generated by Stripe internally
  /// (failed_invoice, void_invoice, or automatic).
  @override
  @JsonKey(name: "cancellation_reason")
  final PaymentIntentCancellationReason? cancellationReason;

  /// The client secret of this PaymentIntent. Used for client-side retrieval
  /// using a publishable key.
  /// The client secret can be used to complete a payment from your frontend.
  /// It should not be stored, logged, or exposed to anyone other than the
  /// customer. Make sure that you have TLS enabled on any page that includes
  /// the client secret.
  ///
  /// Refer to our docs to accept a payment and learn about how `client_secret`
  /// should be handled.
  @override
  @JsonKey(name: "client_secret")
  final String clientSecret;

  /// Controls when the funds will be captured from the customer’s account.
  @override
  @JsonKey(name: "capture_method")
  final PaymentIntentCaptureMethod captureMethod;
  @override
  @JsonKey(name: "confirmation_method")
  final PaymentIntentConfirmationMethod confirmationMethod;

  /// Time at which the object was created. Measured in seconds since the
  /// Unix epoch.
  @override
  final int? created;

  /// Three-letter ISO currency code, in lowercase. Must be a supported
  /// currency.
  @override
  final String currency;

  /// ID of the Customer this PaymentIntent belongs to, if one exists.
  /// Payment methods attached to other Customers cannot be used with this
  /// PaymentIntent.
  ///
  /// If present in combination with setup_future_usage,
  /// this PaymentIntent’s payment method will be attached to the
  /// Customer after the PaymentIntent has been confirmed and any
  /// required actions from the user are complete.
  @override
  final String? customer;

  /// An arbitrary string attached to the object.
  /// Often useful for displaying to users.
  @override
  final String? description;

  /// ID of the invoice that created this PaymentIntent, if it exists.
  @override
  final String? invoice;

  /// The payment error encountered in the previous PaymentIntent confirmation.
  /// It will be cleared if the PaymentIntent is later updated for any reason.
  @override
  @JsonKey(name: "last_payment_error")
  final StripeError? lastPaymentError;

  /// The latest charge created by this payment intent.
  @override
  @JsonKey(name: "latest_charge")
  final String? latestCharge;

  /// Has the value true if the object exists in live mode or the
  /// value false if the object exists in test mode.
  @override
  final bool livemode;

  /// Set of key-value pairs that you can attach to an object.
  /// This can be useful for storing additional information about the
  /// object in a structured format.
  final Map<String, dynamic> _metadata;

  /// Set of key-value pairs that you can attach to an object.
  /// This can be useful for storing additional information about the
  /// object in a structured format.
  @override
  @JsonKey()
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  /// If present, this property tells you what actions you need to
  /// take in order for your customer to fulfill a payment using the
  /// provided source.
  @override
  @JsonKey(name: "next_action")
  final dynamic nextAction;

  /// CONNECT ONLY
  /// The account (if any) for which the funds of the PaymentIntent are
  /// intended. See the PaymentIntents use case for connected accounts
  /// for details.
  @override
  @JsonKey(name: "on_behalf_of")
  final String? onBehalfOf;

  /// ID of the payment method used in this PaymentIntent.
  @override
  @JsonKey(name: "payment_method")
  final String? paymentMethod;

  /// Payment-method-specific configuration for this PaymentIntent.
  final Map<dynamic, dynamic> _paymentMethodOptions;

  /// Payment-method-specific configuration for this PaymentIntent.
  @override
  @JsonKey(name: "payment_method_options")
  Map<dynamic, dynamic> get paymentMethodOptions {
    if (_paymentMethodOptions is EqualUnmodifiableMapView)
      return _paymentMethodOptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_paymentMethodOptions);
  }

  /// The list of payment method types (e.g. card) that this PaymentIntent
  /// is allowed to use.
  final List<PaymentMethodType> _paymentMethodTypes;

  /// The list of payment method types (e.g. card) that this PaymentIntent
  /// is allowed to use.
  @override
  @JsonKey(name: "payment_method_types")
  List<PaymentMethodType> get paymentMethodTypes {
    if (_paymentMethodTypes is EqualUnmodifiableListView)
      return _paymentMethodTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_paymentMethodTypes);
  }

  /// If present, this property tells you about the processing state of the payment.
  @override
  final dynamic processing;

  /// Email address that the receipt for the resulting payment will be sent to.
  /// If receipt_email is specified for a payment in live mode, a receipt
  /// will be sent regardless of your email settings.
  @override
  @JsonKey(name: "receipt_email")
  final String? receiptEmail;
// ID of the review associated with this PaymentIntent, if any.
  @override
  final String? review;

  /// Indicates that you intend to make future payments with this
  /// PaymentIntent’s payment method.
  /// Providing this parameter will attach the payment method to the
  /// PaymentIntent’s Customer, if present, after the PaymentIntent is
  /// confirmed and any required actions from the user are complete. I
  /// If no Customer was provided, the payment method can still be attached to
  /// a Customer after the transaction completes.
  /// When processing card payments, Stripe also uses setup_future_usage
  /// to dynamically optimize your payment flow and comply with regional
  /// legislation and network rules, such as SCA.
  @override
  @JsonKey(name: "setup_future_usage")
  final PaymentIntentSetupFutureUsage? setupFutureUsage;

  /// Shipping information for this PaymentIntent.
  @override
  final ShippingDetails? shipping;

  /// For non-card charges, you can use this value as the complete
  /// description that appears on your customers’ statements.
  /// Must contain at least one letter, maximum 22 characters.
  @override
  @JsonKey(name: "statement_descriptor")
  final String? statementDescriptor;

  /// Provides information about a card payment that customers see on
  /// their statements.
  /// Concatenated with the prefix (shortened descriptor) or statement
  /// descriptor that’s set on the account to form the complete statement
  /// descriptor. Maximum 22 characters for the concatenated descriptor.
  @override
  @JsonKey(name: "statement_descriptor_suffix")
  final String? statementDescriptorSuffix;

  /// Status of this PaymentIntent, one of requires_payment_method,
  /// requires_confirmation, requires_action, processing, requires_capture,
  /// canceled, or succeeded.
  @override
  final PaymentIntentsStatus status;

  /// CONNECT ONLY
  /// The data with which to automatically create a Transfer when the payment
  /// is finalized. See the PaymentIntents use case for connected
  /// accounts for details.
  @override
  @JsonKey(name: "transfer_data")
  final dynamic transferData;

  /// CONNECT ONLY
  /// A string that identifies the resulting payment as part of a group.
  /// See the PaymentIntents use case for connected accounts for details.
  @override
  @JsonKey(name: "transfer_group")
  final dynamic transferGroup;

  @override
  String toString() {
    return 'PaymentIntent(id: $id, object: $object, amount: $amount, amountCapturable: $amountCapturable, amountDetails: $amountDetails, amountReceived: $amountReceived, application: $application, applicationFeeAmount: $applicationFeeAmount, automaticPaymentMethods: $automaticPaymentMethods, canceledAt: $canceledAt, cancellationReason: $cancellationReason, clientSecret: $clientSecret, captureMethod: $captureMethod, confirmationMethod: $confirmationMethod, created: $created, currency: $currency, customer: $customer, description: $description, invoice: $invoice, lastPaymentError: $lastPaymentError, latestCharge: $latestCharge, livemode: $livemode, metadata: $metadata, nextAction: $nextAction, onBehalfOf: $onBehalfOf, paymentMethod: $paymentMethod, paymentMethodOptions: $paymentMethodOptions, paymentMethodTypes: $paymentMethodTypes, processing: $processing, receiptEmail: $receiptEmail, review: $review, setupFutureUsage: $setupFutureUsage, shipping: $shipping, statementDescriptor: $statementDescriptor, statementDescriptorSuffix: $statementDescriptorSuffix, status: $status, transferData: $transferData, transferGroup: $transferGroup)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PaymentIntent &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.amountCapturable, amountCapturable) ||
                other.amountCapturable == amountCapturable) &&
            (identical(other.amountDetails, amountDetails) ||
                other.amountDetails == amountDetails) &&
            (identical(other.amountReceived, amountReceived) ||
                other.amountReceived == amountReceived) &&
            (identical(other.application, application) ||
                other.application == application) &&
            (identical(other.applicationFeeAmount, applicationFeeAmount) ||
                other.applicationFeeAmount == applicationFeeAmount) &&
            (identical(other.automaticPaymentMethods, automaticPaymentMethods) ||
                other.automaticPaymentMethods == automaticPaymentMethods) &&
            (identical(other.canceledAt, canceledAt) ||
                other.canceledAt == canceledAt) &&
            (identical(other.cancellationReason, cancellationReason) ||
                other.cancellationReason == cancellationReason) &&
            (identical(other.clientSecret, clientSecret) ||
                other.clientSecret == clientSecret) &&
            (identical(other.captureMethod, captureMethod) ||
                other.captureMethod == captureMethod) &&
            (identical(other.confirmationMethod, confirmationMethod) ||
                other.confirmationMethod == confirmationMethod) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.currency, currency) ||
                other.currency == currency) &&
            (identical(other.customer, customer) ||
                other.customer == customer) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.invoice, invoice) || other.invoice == invoice) &&
            (identical(other.lastPaymentError, lastPaymentError) ||
                other.lastPaymentError == lastPaymentError) &&
            (identical(other.latestCharge, latestCharge) ||
                other.latestCharge == latestCharge) &&
            (identical(other.livemode, livemode) ||
                other.livemode == livemode) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            const DeepCollectionEquality()
                .equals(other.nextAction, nextAction) &&
            (identical(other.onBehalfOf, onBehalfOf) ||
                other.onBehalfOf == onBehalfOf) &&
            (identical(other.paymentMethod, paymentMethod) ||
                other.paymentMethod == paymentMethod) &&
            const DeepCollectionEquality()
                .equals(other._paymentMethodOptions, _paymentMethodOptions) &&
            const DeepCollectionEquality()
                .equals(other._paymentMethodTypes, _paymentMethodTypes) &&
            const DeepCollectionEquality()
                .equals(other.processing, processing) &&
            (identical(other.receiptEmail, receiptEmail) ||
                other.receiptEmail == receiptEmail) &&
            (identical(other.review, review) || other.review == review) &&
            (identical(other.setupFutureUsage, setupFutureUsage) ||
                other.setupFutureUsage == setupFutureUsage) &&
            (identical(other.shipping, shipping) ||
                other.shipping == shipping) &&
            (identical(other.statementDescriptor, statementDescriptor) ||
                other.statementDescriptor == statementDescriptor) &&
            (identical(other.statementDescriptorSuffix,
                    statementDescriptorSuffix) ||
                other.statementDescriptorSuffix == statementDescriptorSuffix) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality()
                .equals(other.transferData, transferData) &&
            const DeepCollectionEquality()
                .equals(other.transferGroup, transferGroup));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        amount,
        amountCapturable,
        amountDetails,
        amountReceived,
        application,
        applicationFeeAmount,
        automaticPaymentMethods,
        canceledAt,
        cancellationReason,
        clientSecret,
        captureMethod,
        confirmationMethod,
        created,
        currency,
        customer,
        description,
        invoice,
        lastPaymentError,
        latestCharge,
        livemode,
        const DeepCollectionEquality().hash(_metadata),
        const DeepCollectionEquality().hash(nextAction),
        onBehalfOf,
        paymentMethod,
        const DeepCollectionEquality().hash(_paymentMethodOptions),
        const DeepCollectionEquality().hash(_paymentMethodTypes),
        const DeepCollectionEquality().hash(processing),
        receiptEmail,
        review,
        setupFutureUsage,
        shipping,
        statementDescriptor,
        statementDescriptorSuffix,
        status,
        const DeepCollectionEquality().hash(transferData),
        const DeepCollectionEquality().hash(transferGroup)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PaymentIntentCopyWith<_$_PaymentIntent> get copyWith =>
      __$$_PaymentIntentCopyWithImpl<_$_PaymentIntent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PaymentIntentToJson(
      this,
    );
  }
}

abstract class _PaymentIntent implements PaymentIntent {
  const factory _PaymentIntent(
      {required final String id,
      final String object,
      required final int amount,
      @JsonKey(name: "amount_capturable") final int? amountCapturable,
      @JsonKey(name: "amount_details")
      final PaymentIntentAmountDetails? amountDetails,
      @JsonKey(name: "amount_received") final int? amountReceived,
      final String? application,
      @JsonKey(name: "application_fee_amount") final int? applicationFeeAmount,
      @JsonKey(name: "automatic_payment_methods")
      final PaymentIntentAutomaticPaymentMethods? automaticPaymentMethods,
      @JsonKey(name: "canceled_at") final int? canceledAt,
      @JsonKey(name: "cancellation_reason")
      final PaymentIntentCancellationReason? cancellationReason,
      @JsonKey(name: "client_secret") required final String clientSecret,
      @JsonKey(name: "capture_method")
      final PaymentIntentCaptureMethod captureMethod,
      @JsonKey(name: "confirmation_method")
      final PaymentIntentConfirmationMethod confirmationMethod,
      final int? created,
      required final String currency,
      final String? customer,
      final String? description,
      final String? invoice,
      @JsonKey(name: "last_payment_error") final StripeError? lastPaymentError,
      @JsonKey(name: "latest_charge") final String? latestCharge,
      required final bool livemode,
      final Map<String, dynamic> metadata,
      @JsonKey(name: "next_action") final dynamic nextAction,
      @JsonKey(name: "on_behalf_of") final String? onBehalfOf,
      @JsonKey(name: "payment_method") final String? paymentMethod,
      @JsonKey(name: "payment_method_options")
      final Map<dynamic, dynamic> paymentMethodOptions,
      @JsonKey(name: "payment_method_types")
      final List<PaymentMethodType> paymentMethodTypes,
      final dynamic processing,
      @JsonKey(name: "receipt_email") final String? receiptEmail,
      final String? review,
      @JsonKey(name: "setup_future_usage")
      final PaymentIntentSetupFutureUsage? setupFutureUsage,
      final ShippingDetails? shipping,
      @JsonKey(name: "statement_descriptor") final String? statementDescriptor,
      @JsonKey(name: "statement_descriptor_suffix")
      final String? statementDescriptorSuffix,
      required final PaymentIntentsStatus status,
      @JsonKey(name: "transfer_data") final dynamic transferData,
      @JsonKey(name: "transfer_group")
      final dynamic transferGroup}) = _$_PaymentIntent;

  factory _PaymentIntent.fromJson(Map<String, dynamic> json) =
      _$_PaymentIntent.fromJson;

  @override

  /// Unique identifier for the object.
  String get id;
  @override

  /// String representing the object’s type.
  /// Objects of the same type share the same value.
  /// Value is "payment_intent".
  String get object;
  @override

  /// Amount intended to be collected by this PaymentIntent.
  /// A positive integer representing how much to charge in the
  /// smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to
  /// charge ¥100, a zero-decimal currency).
  /// The minimum amount is $0.50 US or equivalent in charge currency.
  /// The amount value supports up to eight digits
  /// (e.g., a value of 99999999 for a USD charge of $999,999.99).
  int get amount;
  @override

  /// The amount that can be captured with from this PaymentIntent (in cents).
  @JsonKey(name: "amount_capturable")
  int? get amountCapturable;
  @override

  /// Details about items included in the amount
  @JsonKey(name: "amount_details")
  PaymentIntentAmountDetails? get amountDetails;
  @override

  /// The amount that was collected from this PaymentIntent (in cents).
  @JsonKey(name: "amount_received")
  int? get amountReceived;
  @override

  /// CONNECT ONLY
  /// ID of the Connect application that created the PaymentIntent.
  String? get application;
  @override

  /// CONNECT ONLY
  /// The amount of the application fee (if any) that will be requested to
  /// be applied to the payment and transferred to the application owner’s
  /// Stripe account. The amount of the application fee collected will be
  /// capped at the total payment amount.
  /// For more information, see the PaymentIntents use
  /// case for connected accounts..
  @JsonKey(name: "application_fee_amount")
  int? get applicationFeeAmount;
  @override

  /// Settings to configure compatible payment methods from the
  /// Stripe Dashboard
  @JsonKey(name: "automatic_payment_methods")
  PaymentIntentAutomaticPaymentMethods? get automaticPaymentMethods;
  @override

  /// Populated when status is canceled, this is the time at which the
  /// PaymentIntent was canceled. Measured in seconds since the Unix epoch.
  @JsonKey(name: "canceled_at")
  int? get canceledAt;
  @override

  /// Reason for cancellation of this PaymentIntent,
  /// either user-provided
  /// (duplicate, fraudulent, requested_by_customer, or abandoned) or
  /// generated by Stripe internally
  /// (failed_invoice, void_invoice, or automatic).
  @JsonKey(name: "cancellation_reason")
  PaymentIntentCancellationReason? get cancellationReason;
  @override

  /// The client secret of this PaymentIntent. Used for client-side retrieval
  /// using a publishable key.
  /// The client secret can be used to complete a payment from your frontend.
  /// It should not be stored, logged, or exposed to anyone other than the
  /// customer. Make sure that you have TLS enabled on any page that includes
  /// the client secret.
  ///
  /// Refer to our docs to accept a payment and learn about how `client_secret`
  /// should be handled.
  @JsonKey(name: "client_secret")
  String get clientSecret;
  @override

  /// Controls when the funds will be captured from the customer’s account.
  @JsonKey(name: "capture_method")
  PaymentIntentCaptureMethod get captureMethod;
  @override
  @JsonKey(name: "confirmation_method")
  PaymentIntentConfirmationMethod get confirmationMethod;
  @override

  /// Time at which the object was created. Measured in seconds since the
  /// Unix epoch.
  int? get created;
  @override

  /// Three-letter ISO currency code, in lowercase. Must be a supported
  /// currency.
  String get currency;
  @override

  /// ID of the Customer this PaymentIntent belongs to, if one exists.
  /// Payment methods attached to other Customers cannot be used with this
  /// PaymentIntent.
  ///
  /// If present in combination with setup_future_usage,
  /// this PaymentIntent’s payment method will be attached to the
  /// Customer after the PaymentIntent has been confirmed and any
  /// required actions from the user are complete.
  String? get customer;
  @override

  /// An arbitrary string attached to the object.
  /// Often useful for displaying to users.
  String? get description;
  @override

  /// ID of the invoice that created this PaymentIntent, if it exists.
  String? get invoice;
  @override

  /// The payment error encountered in the previous PaymentIntent confirmation.
  /// It will be cleared if the PaymentIntent is later updated for any reason.
  @JsonKey(name: "last_payment_error")
  StripeError? get lastPaymentError;
  @override

  /// The latest charge created by this payment intent.
  @JsonKey(name: "latest_charge")
  String? get latestCharge;
  @override

  /// Has the value true if the object exists in live mode or the
  /// value false if the object exists in test mode.
  bool get livemode;
  @override

  /// Set of key-value pairs that you can attach to an object.
  /// This can be useful for storing additional information about the
  /// object in a structured format.
  Map<String, dynamic> get metadata;
  @override

  /// If present, this property tells you what actions you need to
  /// take in order for your customer to fulfill a payment using the
  /// provided source.
  @JsonKey(name: "next_action")
  dynamic get nextAction;
  @override

  /// CONNECT ONLY
  /// The account (if any) for which the funds of the PaymentIntent are
  /// intended. See the PaymentIntents use case for connected accounts
  /// for details.
  @JsonKey(name: "on_behalf_of")
  String? get onBehalfOf;
  @override

  /// ID of the payment method used in this PaymentIntent.
  @JsonKey(name: "payment_method")
  String? get paymentMethod;
  @override

  /// Payment-method-specific configuration for this PaymentIntent.
  @JsonKey(name: "payment_method_options")
  Map<dynamic, dynamic> get paymentMethodOptions;
  @override

  /// The list of payment method types (e.g. card) that this PaymentIntent
  /// is allowed to use.
  @JsonKey(name: "payment_method_types")
  List<PaymentMethodType> get paymentMethodTypes;
  @override

  /// If present, this property tells you about the processing state of the payment.
  dynamic get processing;
  @override

  /// Email address that the receipt for the resulting payment will be sent to.
  /// If receipt_email is specified for a payment in live mode, a receipt
  /// will be sent regardless of your email settings.
  @JsonKey(name: "receipt_email")
  String? get receiptEmail;
  @override // ID of the review associated with this PaymentIntent, if any.
  String? get review;
  @override

  /// Indicates that you intend to make future payments with this
  /// PaymentIntent’s payment method.
  /// Providing this parameter will attach the payment method to the
  /// PaymentIntent’s Customer, if present, after the PaymentIntent is
  /// confirmed and any required actions from the user are complete. I
  /// If no Customer was provided, the payment method can still be attached to
  /// a Customer after the transaction completes.
  /// When processing card payments, Stripe also uses setup_future_usage
  /// to dynamically optimize your payment flow and comply with regional
  /// legislation and network rules, such as SCA.
  @JsonKey(name: "setup_future_usage")
  PaymentIntentSetupFutureUsage? get setupFutureUsage;
  @override

  /// Shipping information for this PaymentIntent.
  ShippingDetails? get shipping;
  @override

  /// For non-card charges, you can use this value as the complete
  /// description that appears on your customers’ statements.
  /// Must contain at least one letter, maximum 22 characters.
  @JsonKey(name: "statement_descriptor")
  String? get statementDescriptor;
  @override

  /// Provides information about a card payment that customers see on
  /// their statements.
  /// Concatenated with the prefix (shortened descriptor) or statement
  /// descriptor that’s set on the account to form the complete statement
  /// descriptor. Maximum 22 characters for the concatenated descriptor.
  @JsonKey(name: "statement_descriptor_suffix")
  String? get statementDescriptorSuffix;
  @override

  /// Status of this PaymentIntent, one of requires_payment_method,
  /// requires_confirmation, requires_action, processing, requires_capture,
  /// canceled, or succeeded.
  PaymentIntentsStatus get status;
  @override

  /// CONNECT ONLY
  /// The data with which to automatically create a Transfer when the payment
  /// is finalized. See the PaymentIntents use case for connected
  /// accounts for details.
  @JsonKey(name: "transfer_data")
  dynamic get transferData;
  @override

  /// CONNECT ONLY
  /// A string that identifies the resulting payment as part of a group.
  /// See the PaymentIntents use case for connected accounts for details.
  @JsonKey(name: "transfer_group")
  dynamic get transferGroup;
  @override
  @JsonKey(ignore: true)
  _$$_PaymentIntentCopyWith<_$_PaymentIntent> get copyWith =>
      throw _privateConstructorUsedError;
}

PaymentIntentAmountDetails _$PaymentIntentAmountDetailsFromJson(
    Map<String, dynamic> json) {
  return _PaymentIntentAmountDetails.fromJson(json);
}

/// @nodoc
mixin _$PaymentIntentAmountDetails {
  /// Details about items included in the amount
  PaymentIntentTip? get tip => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PaymentIntentAmountDetailsCopyWith<PaymentIntentAmountDetails>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentIntentAmountDetailsCopyWith<$Res> {
  factory $PaymentIntentAmountDetailsCopyWith(PaymentIntentAmountDetails value,
          $Res Function(PaymentIntentAmountDetails) then) =
      _$PaymentIntentAmountDetailsCopyWithImpl<$Res,
          PaymentIntentAmountDetails>;
  @useResult
  $Res call({PaymentIntentTip? tip});

  $PaymentIntentTipCopyWith<$Res>? get tip;
}

/// @nodoc
class _$PaymentIntentAmountDetailsCopyWithImpl<$Res,
        $Val extends PaymentIntentAmountDetails>
    implements $PaymentIntentAmountDetailsCopyWith<$Res> {
  _$PaymentIntentAmountDetailsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tip = freezed,
  }) {
    return _then(_value.copyWith(
      tip: freezed == tip
          ? _value.tip
          : tip // ignore: cast_nullable_to_non_nullable
              as PaymentIntentTip?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PaymentIntentTipCopyWith<$Res>? get tip {
    if (_value.tip == null) {
      return null;
    }

    return $PaymentIntentTipCopyWith<$Res>(_value.tip!, (value) {
      return _then(_value.copyWith(tip: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PaymentIntentAmountDetailsCopyWith<$Res>
    implements $PaymentIntentAmountDetailsCopyWith<$Res> {
  factory _$$_PaymentIntentAmountDetailsCopyWith(
          _$_PaymentIntentAmountDetails value,
          $Res Function(_$_PaymentIntentAmountDetails) then) =
      __$$_PaymentIntentAmountDetailsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({PaymentIntentTip? tip});

  @override
  $PaymentIntentTipCopyWith<$Res>? get tip;
}

/// @nodoc
class __$$_PaymentIntentAmountDetailsCopyWithImpl<$Res>
    extends _$PaymentIntentAmountDetailsCopyWithImpl<$Res,
        _$_PaymentIntentAmountDetails>
    implements _$$_PaymentIntentAmountDetailsCopyWith<$Res> {
  __$$_PaymentIntentAmountDetailsCopyWithImpl(
      _$_PaymentIntentAmountDetails _value,
      $Res Function(_$_PaymentIntentAmountDetails) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tip = freezed,
  }) {
    return _then(_$_PaymentIntentAmountDetails(
      tip: freezed == tip
          ? _value.tip
          : tip // ignore: cast_nullable_to_non_nullable
              as PaymentIntentTip?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PaymentIntentAmountDetails implements _PaymentIntentAmountDetails {
  const _$_PaymentIntentAmountDetails({this.tip = const PaymentIntentTip()});

  factory _$_PaymentIntentAmountDetails.fromJson(Map<String, dynamic> json) =>
      _$$_PaymentIntentAmountDetailsFromJson(json);

  /// Details about items included in the amount
  @override
  @JsonKey()
  final PaymentIntentTip? tip;

  @override
  String toString() {
    return 'PaymentIntentAmountDetails(tip: $tip)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PaymentIntentAmountDetails &&
            (identical(other.tip, tip) || other.tip == tip));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, tip);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PaymentIntentAmountDetailsCopyWith<_$_PaymentIntentAmountDetails>
      get copyWith => __$$_PaymentIntentAmountDetailsCopyWithImpl<
          _$_PaymentIntentAmountDetails>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PaymentIntentAmountDetailsToJson(
      this,
    );
  }
}

abstract class _PaymentIntentAmountDetails
    implements PaymentIntentAmountDetails {
  const factory _PaymentIntentAmountDetails({final PaymentIntentTip? tip}) =
      _$_PaymentIntentAmountDetails;

  factory _PaymentIntentAmountDetails.fromJson(Map<String, dynamic> json) =
      _$_PaymentIntentAmountDetails.fromJson;

  @override

  /// Details about items included in the amount
  PaymentIntentTip? get tip;
  @override
  @JsonKey(ignore: true)
  _$$_PaymentIntentAmountDetailsCopyWith<_$_PaymentIntentAmountDetails>
      get copyWith => throw _privateConstructorUsedError;
}

PaymentIntentTip _$PaymentIntentTipFromJson(Map<String, dynamic> json) {
  return _PaymentIntentTip.fromJson(json);
}

/// @nodoc
mixin _$PaymentIntentTip {
  /// Portion of the amount that corresponds to a tip.
  int? get amount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PaymentIntentTipCopyWith<PaymentIntentTip> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentIntentTipCopyWith<$Res> {
  factory $PaymentIntentTipCopyWith(
          PaymentIntentTip value, $Res Function(PaymentIntentTip) then) =
      _$PaymentIntentTipCopyWithImpl<$Res, PaymentIntentTip>;
  @useResult
  $Res call({int? amount});
}

/// @nodoc
class _$PaymentIntentTipCopyWithImpl<$Res, $Val extends PaymentIntentTip>
    implements $PaymentIntentTipCopyWith<$Res> {
  _$PaymentIntentTipCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = freezed,
  }) {
    return _then(_value.copyWith(
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PaymentIntentTipCopyWith<$Res>
    implements $PaymentIntentTipCopyWith<$Res> {
  factory _$$_PaymentIntentTipCopyWith(
          _$_PaymentIntentTip value, $Res Function(_$_PaymentIntentTip) then) =
      __$$_PaymentIntentTipCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? amount});
}

/// @nodoc
class __$$_PaymentIntentTipCopyWithImpl<$Res>
    extends _$PaymentIntentTipCopyWithImpl<$Res, _$_PaymentIntentTip>
    implements _$$_PaymentIntentTipCopyWith<$Res> {
  __$$_PaymentIntentTipCopyWithImpl(
      _$_PaymentIntentTip _value, $Res Function(_$_PaymentIntentTip) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = freezed,
  }) {
    return _then(_$_PaymentIntentTip(
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PaymentIntentTip implements _PaymentIntentTip {
  const _$_PaymentIntentTip({this.amount});

  factory _$_PaymentIntentTip.fromJson(Map<String, dynamic> json) =>
      _$$_PaymentIntentTipFromJson(json);

  /// Portion of the amount that corresponds to a tip.
  @override
  final int? amount;

  @override
  String toString() {
    return 'PaymentIntentTip(amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PaymentIntentTip &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, amount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PaymentIntentTipCopyWith<_$_PaymentIntentTip> get copyWith =>
      __$$_PaymentIntentTipCopyWithImpl<_$_PaymentIntentTip>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PaymentIntentTipToJson(
      this,
    );
  }
}

abstract class _PaymentIntentTip implements PaymentIntentTip {
  const factory _PaymentIntentTip({final int? amount}) = _$_PaymentIntentTip;

  factory _PaymentIntentTip.fromJson(Map<String, dynamic> json) =
      _$_PaymentIntentTip.fromJson;

  @override

  /// Portion of the amount that corresponds to a tip.
  int? get amount;
  @override
  @JsonKey(ignore: true)
  _$$_PaymentIntentTipCopyWith<_$_PaymentIntentTip> get copyWith =>
      throw _privateConstructorUsedError;
}

PaymentIntentAutomaticPaymentMethods
    _$PaymentIntentAutomaticPaymentMethodsFromJson(Map<String, dynamic> json) {
  return _PaymentIntentAutomaticPaymentMethods.fromJson(json);
}

/// @nodoc
mixin _$PaymentIntentAutomaticPaymentMethods {
  /// Automatically calculates compatible payment methods
  bool? get enabled => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PaymentIntentAutomaticPaymentMethodsCopyWith<
          PaymentIntentAutomaticPaymentMethods>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  factory $PaymentIntentAutomaticPaymentMethodsCopyWith(
          PaymentIntentAutomaticPaymentMethods value,
          $Res Function(PaymentIntentAutomaticPaymentMethods) then) =
      _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<$Res,
          PaymentIntentAutomaticPaymentMethods>;
  @useResult
  $Res call({bool? enabled});
}

/// @nodoc
class _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<$Res,
        $Val extends PaymentIntentAutomaticPaymentMethods>
    implements $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = freezed,
  }) {
    return _then(_value.copyWith(
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PaymentIntentAutomaticPaymentMethodsCopyWith<$Res>
    implements $PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  factory _$$_PaymentIntentAutomaticPaymentMethodsCopyWith(
          _$_PaymentIntentAutomaticPaymentMethods value,
          $Res Function(_$_PaymentIntentAutomaticPaymentMethods) then) =
      __$$_PaymentIntentAutomaticPaymentMethodsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool? enabled});
}

/// @nodoc
class __$$_PaymentIntentAutomaticPaymentMethodsCopyWithImpl<$Res>
    extends _$PaymentIntentAutomaticPaymentMethodsCopyWithImpl<$Res,
        _$_PaymentIntentAutomaticPaymentMethods>
    implements _$$_PaymentIntentAutomaticPaymentMethodsCopyWith<$Res> {
  __$$_PaymentIntentAutomaticPaymentMethodsCopyWithImpl(
      _$_PaymentIntentAutomaticPaymentMethods _value,
      $Res Function(_$_PaymentIntentAutomaticPaymentMethods) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = freezed,
  }) {
    return _then(_$_PaymentIntentAutomaticPaymentMethods(
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PaymentIntentAutomaticPaymentMethods
    implements _PaymentIntentAutomaticPaymentMethods {
  const _$_PaymentIntentAutomaticPaymentMethods({required this.enabled});

  factory _$_PaymentIntentAutomaticPaymentMethods.fromJson(
          Map<String, dynamic> json) =>
      _$$_PaymentIntentAutomaticPaymentMethodsFromJson(json);

  /// Automatically calculates compatible payment methods
  @override
  final bool? enabled;

  @override
  String toString() {
    return 'PaymentIntentAutomaticPaymentMethods(enabled: $enabled)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PaymentIntentAutomaticPaymentMethods &&
            (identical(other.enabled, enabled) || other.enabled == enabled));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, enabled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PaymentIntentAutomaticPaymentMethodsCopyWith<
          _$_PaymentIntentAutomaticPaymentMethods>
      get copyWith => __$$_PaymentIntentAutomaticPaymentMethodsCopyWithImpl<
          _$_PaymentIntentAutomaticPaymentMethods>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PaymentIntentAutomaticPaymentMethodsToJson(
      this,
    );
  }
}

abstract class _PaymentIntentAutomaticPaymentMethods
    implements PaymentIntentAutomaticPaymentMethods {
  const factory _PaymentIntentAutomaticPaymentMethods(
      {required final bool? enabled}) = _$_PaymentIntentAutomaticPaymentMethods;

  factory _PaymentIntentAutomaticPaymentMethods.fromJson(
          Map<String, dynamic> json) =
      _$_PaymentIntentAutomaticPaymentMethods.fromJson;

  @override

  /// Automatically calculates compatible payment methods
  bool? get enabled;
  @override
  @JsonKey(ignore: true)
  _$$_PaymentIntentAutomaticPaymentMethodsCopyWith<
          _$_PaymentIntentAutomaticPaymentMethods>
      get copyWith => throw _privateConstructorUsedError;
}
